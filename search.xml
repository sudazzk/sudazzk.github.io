<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown 文档管理工具]]></title>
    <url>%2F2019%2F12%2F19%2Fdoc_markdown%2F</url>
    <content type="text"><![CDATA[Markdown 文档管理工具（静态网站生成器） 一键生成：https://github.com/matusnovak/doxybook 下载量趋势图：https://www.npmtrends.com/docsify-vs-docute-vs-gitbook-vs-vuepress-vs-mkdocs 对比：http://www.amdoing.com/static-site-generator-hexo-gitbook-vuepress-and-so-on/ docsify 中文官网 github+docsify生成文档网站 docsify-写一个自己的网站 docsify 不一样的文档工具 Docsify快速搭建个人博客 docsify - 生成文档网站简单使用教程 mkdocs 中文文档 使用 Mkdocs 在 Github 上快速部署文章 vuepress 中文官网 VuePress超详细简单教程 手把手教你使用 VuePress 搭建个人博客 docute 中文官网 gitbook 官网 Hexo 中文文档 Jekyll 中文官网]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neo4j 使用教程]]></title>
    <url>%2F2019%2F12%2F02%2Fneo4j%2F</url>
    <content type="text"><![CDATA[[TOC] 一、介绍相关链接 官网：https://neo4j.com/ 官方手册：https://neo4j.com/docs/operations-manual/current/ 中文文档：http://neo4j.com.cn/public/docs/index.html neo4j教程：https://www.w3cschool.cn/neo4j/ neo4j 初步认识和使用：https://segmentfault.com/a/1190000014488430?utm_source=tag-newest Neo4j基础介绍：https://blog.csdn.net/liudongdong19/article/details/82772104 Neo4j 学习笔记（-）：https://www.cnblogs.com/infoo/p/9840965.html Neo4j 学习笔记（二）：https://www.cnblogs.com/infoo/p/11947467.html neo4j 开启远程web访问7474端口 以 用浏览器打开远程neo4j的web控制台界面 图数据库哪家强，图数据库选型入门指南 启动Neo4j失败：地址localhost：7474已经在使用 基础知识 目前最流行的高性能的NoSQL图形数据库，结构化数据存储在网络上而不是在表中，完全由java开发 支持完整的事务，在属性图中，图是由顶点（Vertex），边（Edge）和属性（Property）组成的，顶点和边都可以设置属性，顶点也称作节点，边也称作关系，每个节点和关系都可以由一个或多个属性。 Neo4j创建的图是用顶点和边构建一个有向图，其查询语言cypher已经成为事实上的标准。 二、安装链接 社区版：https://neo4j.com/download-center/#community 链接地址（Linux版）：https://neo4j.com/artifact.php?name=neo4j-community-3.5.13-unix.tar.gz 链接地址（Windows）：https://neo4j.com/artifact.php?name=neo4j-community-3.5.13-windows.zip 命令12345678tar -xf neo4j-community-3.5.13-unix.tar.gzcd neo4j-community-3.5.13/## 取消54行注释dbms.connectors.default_listen_address=0.0.0.0./bin/neo4j console # 以控制台应用运行./bin/neo4j start # 以后台进程运行 浏览器 http://localhost:7474/ 初始用户名和密码：neo4j 修改密码：neo4j. 三、Python操作学习链接 The Py2neo v4 Handbook 在python中使用neo4j全过程 python操作neo4j 【较详细】 python通过py2neo模块操作Neo4j图数据库 neo4j︱与python结合的py2neo使用教程（四） py2neo使用指南 py2neo基本用法 安装 py2neo：python -m pip install py2neo 创建代码12345678910111213141516from py2neo import Node, Relationship, Graph, NodeMatcher, RelationshipMatcher# 新建图形graph = Graph('http://localhost:7474', username='neo4j', password='neo4j.')# 新建nodea = Node('label', name = 'a' )b = Node('label', name = 'b' )# 在graph中绘制nodegraph.create(a)graph.create(b)# 新建关系并绘制r1 = Relationship(a, 'to', b, name = 'to') #可以增加一些属性，也可以省略graph.create(r1) 相关术语图 Graph graph = Graph(url,username=’name’,password=’pw’) 节点 Node 构成一张图的基本元素是节点和关系。 在Neo4j中，节点和关系都可以包含属性。 class Node(labels, *properties) 关系 Relationship 节点之间的关系是图数据库很重要的一部分。 一个关系连接两个节点，必须有一个开始节点和结束节点。 class Relationship(start_node, type, end_node, **properties) 属性 节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。 属性值是要么是原始值，要么是原始值类型的一个数组。 查询代码 后续补充… 四、数据导入链接 图数据库 Neo4j 的部署、数据导入和简单使用 学习Neo4j几小时小结~批量导入数据 使用neo4j图数据库的import工具导入数据 -方法和注意事项 Neo4j—数据导入JM68 方法数据样例：./zzk/person.txt12345678910111213141516一灯大师 技能/武功 一阳指一灯大师 传功 王重阳王重阳 师弟 周伯通周伯通 别名 老顽童周伯通 义弟 郭靖郭靖 义弟 杨康杨康 儿子 杨过杨过 妻子 小龙女杨过 师傅 小龙女小龙女 后人 黄衫女子黄衫女子 惩戒 周芷若郭靖 女儿 郭襄郭襄 创立 峨嵋派周芷若 因爱生恨 张无忌张君宝 创立 武当派张无忌 太师父 张君宝 处理数据：./zzk/do_data.py1234567891011121314151617181920212223242526def read_write(txt_file, node_file, edge_file): node_dict = &#123;&#125; with open(txt_file, "r", encoding="utf-8") as ft: for line in ft: row = line.rstrip().split() if row[0] not in node_dict: node_dict[row[0]] = len(node_dict) if row[2] not in node_dict: node_dict[row[2]] = len(node_dict) with open(node_file, "w", encoding="utf-8") as fn: fn.write("entity:ID,name,:LABEL" + "\n") for node in node_dict: fn.write("e" + str(node_dict[node]) + "," + node + ",Entity\n") with open(edge_file, "w", encoding="utf-8") as fe: fe.write(":START_ID,:END_ID,:TYPE" + "\n") with open(txt_file, "r", encoding="utf-8") as ft: for line in ft: row = line.rstrip().split() fe.write("e"+str(node_dict[row[0]]) + "," + "e"+str(node_dict[row[2]]) + "," + row[1] + "\n")if __name__ == "__main__": read_write("person.txt", "node.csv", "edge.csv") 处理结果：./zzk/node.csv1234567891011121314151617entity:ID,name,:LABELe0,一灯大师,Entitye1,一阳指,Entitye2,王重阳,Entitye3,周伯通,Entitye4,老顽童,Entitye5,郭靖,Entitye6,杨康,Entitye7,杨过,Entitye8,小龙女,Entitye9,黄衫女子,Entitye10,周芷若,Entitye11,郭襄,Entitye12,峨嵋派,Entitye13,张无忌,Entitye14,张君宝,Entitye15,武当派,Entity 处理结果：./zzk/edge.csv1234567891011121314151617:START_ID,:END_ID,:TYPEe0,e1,技能/武功e0,e2,传功e2,e3,师弟e3,e4,别名e3,e5,义弟e5,e6,义弟e6,e7,儿子e7,e8,妻子e7,e8,师傅e8,e9,后人e9,e10,惩戒e5,e11,女儿e11,e12,创立e10,e13,因爱生恨e14,e15,创立e13,e14,太师父 导入数据1./bin/neo4j-import --into ./data/databases/new_graph.db --nodes ./zzk/node.csv --relationships ./zzk/edge.csv 查看 修改配置文件：vim ./conf/neo4j.conf 第9行 dbms.active_database=new_graph.db 命令：./bin/neo4j console 浏览器：http://localhost:7474 删库跑路 rm -rf ./data/databases/new_graph.db]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>Python</tag>
        <tag>图数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指 Offer （Python 版）]]></title>
    <url>%2F2019%2F11%2F09%2Fjianzhi_offer%2F</url>
    <content type="text"><![CDATA[[TOC] 01.二维数组中的查找 Q：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 A：从左下或者右上开始查找1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here rowN = len(array) colN = len(array[0]) i = rowN - 1 j = 0 while i&gt;=0 and j &lt; colN: if target == array[i][j]: return True elif target &gt; array[i][j]: j += 1 elif target &lt; array[i][j]: i -= 1 return False 02.替换空格 Q：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 A：先计算空格数量，从后往前替换1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here # return s.replace(" ", "%20") # s1 = s.split(" ") # return "%20".join(s1) s = list(s) count = 0 for c in s: if c == " ": count += 1 i = len(s) - 1 s += ["0"] * count * 2 while i &gt;= 0: if s[i] != " ": s[i+2*count] = s[i] else: count -= 1 s[i+2*count] = "%" s[i+2*count+1] = "2" s[i+2*count+2] = "0" i -= 1 return "".join(s) 03.从尾到头打印链表 Q：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 A：头插法12345678910111213# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here if listNode == None: return [] return self.printListFromTailToHead(listNode.next) + [listNode.val] # 递归 04.重建二叉树 Q：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 A：【前序遍历：根左右】【中序遍历：左根右】12345678910111213141516171819202122232425# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if not pre or not tin: return None root = TreeNode(pre[0]) # list.pop([index=-1]) index = tin.index(root.val) # 左子树有 index 个结点 root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root&apos;&apos;&apos; # pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 root = TreeNode(pre.pop(0)) # list.pop([index=-1]) index = tin.index(root.val) # 递归操作 root.left = self.reConstructBinaryTree(pre, tin[:index]) root.right = self.reConstructBinaryTree(pre, tin[index+1:]) return root&apos;&apos;&apos; 05.用两个栈实现队列 Q：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 A：栈2 辅助 栈1 操作123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if len(self.stack1): while len(self.stack1): self.stack2.append(self.stack1.pop()) val = self.stack2.pop() while len(self.stack2): self.stack1.append(self.stack2.pop()) return val else: return None 06.旋转数组的最小数字 Q：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0 A：二分查找的变型12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 else: L = 0 R = len(rotateArray) - 1 while L &lt; R: if rotateArray[L] &lt; rotateArray[R]: return rotateArray[L] M = (L + R) / 2 if rotateArray[L] &lt; rotateArray[M]: # 左边是有序数组，最小值在右边 L = M + 1 elif rotateArray[M] &lt; rotateArray[R]: # 右边是有序数组，最小值在左边 R = M else: L += 1 return rotateArray[L] 07.斐波那契数列 Q：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 A：记住前两个123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n == 0: return 0 elif n == 1: return 1 else: N = 2 N_2 = 0 N_1 = 1 while n &gt; N: N += 1 K = N_1 N_1 = N_2 + N_1 # 每次记住前两个 N_2 = K return N_2 + N_1 # 此时 n == N# if n == 0:# return 0# elif n == 1:# return 1# else:# return self.Fibonacci(n-2) + self.Fibonacci(n-1) # 会溢出 08.跳台阶 Q：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 A：推导公式123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number == 1: return 1 elif number == 2: return 2 else: f1 = 1 f2 = 2 for i in range(3, number+1): cur = f1 + f2 f1 = f2 f2 = cur return cur# if number == 1:# return 1# elif number == 2:# return 2# else:# return self.jumpFloor(number-2) + self.jumpFloor(number-1) 09.变态跳台阶 Q：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 A：推导1234567891011121314# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here return 2 ** (number-1)# 先看跳的第一步# 跳 1 级：剩下 f(n-1)# 跳 2 级：剩下 f(n-2)# ...# 跳 n-1 级：剩下 f(n-(n-1))# 跳 n 级：剩下 f(n-n)# f(n)=f(0)+f(1)+...+f(n-1)=2*f(n-1)# f(1)=1 10.矩形覆盖 Q：我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ A：推导1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number == 0: return 0 elif number == 1: return 1 elif number == 2: return 2 else: f1 = 1 f2 = 2 for i in range(3, number+1): cur = f1 + f2 f1 = f2 f2 = cur return cur# n=0 0 # 容易错# n=1 1# n=2 2# n=3 f(n)=f(n-1)+f(n-2) 11.二进制中1的个数 Q：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 A：负数转为正的表示1234567891011121314# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here sum = 0 if n &lt; 0: n = n &amp; 0xffffffff # 先把负数的补码转为正数的表示 while n: sum += 1 n = (n-1) &amp; n return sum# 最高位是符号位，0是正数，1是负数，原码=符号位+数值位# 反码：对于负数，数符位为1，数符位不变，将数值位诸位取反为反码。# 补码：对于负数，数符位为1，数符位不变，将反码＋1＝补码。 12.数值的整数次方 Q：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 A：123456789101112131415# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here result = 1.0 if exponent == 0: result = 1 elif exponent &gt; 0: for i in range(1, exponent+1): result *= base else: for i in range(1, (-exponent)+1): result *= base result = 1/result return result 13.调整数组顺序使奇数位于偶数前面 Q：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 A：稳定排序1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0: return [] L = len(array) # for i in range(0, L-1): # 冒泡排序# for j in range(0, L-1-i):# if array[j]%2==0 and array[j+1]%2==1:# array[j], array[j+1] = array[j+1], array[j]# return array for i in range(1, L): # 插入排序 j = i while j &gt; 0 and array[j]%2==1 and array[j-1]%2==0: array[j], array[j-1] = array[j-1], array[j] j -= 1 return array 14.链表中倒数第k个结点 Q：输入一个链表，输出该链表中倒数第k个结点。 A：双指针12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here # if head==None or k&lt;=0: # return None # a = head # 两个指针协作，相差k-1步 !!!!!!!! # b = head # while k &gt; 1: # if b.next: # k -= 1 # b = b.next # else: # return None # while b.next: # a = a.next # b = b.next # return a stack = [] # 链栈 while head: stack.append(head) head = head.next if k&gt;len(stack) or k&lt;=0: return None return stack[-k] 15.反转链表 Q：输入一个链表，反转链表后，输出新链表的表头。 A：递归 或 循环12345678910111213141516171819202122232425# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # 头节点pHead是空的 # write code here if pHead==None or pHead.next==None: return pHead pre = self.ReverseList(pHead.next) pHead.next.next = pHead pHead.next = None return pre''' pre = None cur = pHead while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre''' 16.合并两个排序的链表 Q：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 A：循环 或 递归1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here newHead = ListNode(0) tmp = newHead while pHead1 and pHead2: if pHead1.val &lt; pHead2.val: tmp.next = pHead1 pHead1 = pHead1.next else: tmp.next = pHead2 pHead2 = pHead2.next tmp = tmp.next if pHead1 == None: tmp.next = pHead2 elif pHead2 == None: tmp.next = pHead1 return newHead.next''' if pHead1 == None: return pHead2 if pHead2 == None: return pHead1 if pHead1.val &lt;= pHead2.val: pHead1.next = self.Merge(pHead1.next, pHead2) return pHead1 else: pHead2.next = self.Merge(pHead1, pHead2.next) return pHead2''' 17.树的子结构 Q：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） A：递归123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here res = False if pRoot1 and pRoot2: if pRoot1.val == pRoot2.val: res = self.T1_Has_T2(pRoot1, pRoot2) if not res: res = self.T1_Has_T2(pRoot1.left, pRoot2) if not res: res = self.T1_Has_T2(pRoot1.right, pRoot2) return res def T1_Has_T2(self, pRoot1, pRoot2): if pRoot2 == None: # 先（说明B树已经遍历结束） return True if pRoot1 == None: # 后 return False if pRoot1.val != pRoot2.val: return False return self.T1_Has_T2(pRoot1.left, pRoot2.left) and self.T1_Has_T2(pRoot1.right, pRoot2.right) 18.二叉树的镜像 Q：操作给定的二叉树，将其变换为源二叉树的镜像。 A：递归 123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 A： 1234567891011121314# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if root: root.left, root.right = root.right, root.left self.Mirror(root.left) self.Mirror(root.right) 19.顺时针打印矩阵 Q：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. A：记录层数12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here res = [] if len(matrix) == 0: return res rowN = len(matrix) colN = len(matrix[0]) L = (min(rowN, colN)-1)/2+1 # 层数 for i in range(L): for k in range(i, colN-i): # 从左到右（层号对应行号） res.append(matrix[i][k]) for j in range(i+1, rowN-i): # 从右上到右下 res.append(matrix[j][colN-i-1]) for k in range(colN-i-2, i-1, -1): # 从右到左 if rowN-i-1 != i: # 只有1行 res.append(matrix[rowN-i-1][k]) for j in range(rowN-i-2, i, -1): if colN-i-1 != i: # 只有1列 res.append(matrix[j][i]) # 从左下到左上（层号对应列号） return res 20.包含min函数的栈 Q：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 A：辅助栈放最小值1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack = [] self.minStack = [] def push(self, node): # write code here self.stack.append(node) if len(self.minStack) == 0: self.minStack.append(node) else: self.minStack.append(min(self.minStack[-1], node)) def pop(self): # write code here if len(self.stack) == 0: return None self.minStack.pop() return self.stack.pop() def top(self): # write code here if len(self.stack) == 0: return None return self.stack[-1] def min(self): # write code here if len(self.minStack) == 0: return None return self.minStack[-1] 21.栈的压入、弹出序列 Q：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） A：就按栈的操作进行【入栈期间可以出栈】1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # 入栈中途可以出栈 # write code here if pushV == [] or popV == []: return False stack = [] for i in pushV: stack.append(i) while len(stack) and stack[-1] == popV[0]: stack.pop() popV.pop(0) if len(stack): return False else: return True 22.从上往下打印二叉树 Q：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 A：引入一个队列123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if root == None: return [] queue = [] # 队列 res = [] queue.append(root) while len(queue): cur = queue.pop(0) res.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return res 23.二叉搜索树的后序遍历序列 Q：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 A：【后序遍历：左右根】123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here 二叉搜索树，二叉排序树，左&lt;根&lt;右 if sequence == []: return False root = sequence[-1] # 根 L = len(sequence) for i in range(L): if sequence[i] &gt; root: # 左 break for j in range(i, L): if sequence[j] &lt; root: # 右 return False left = True if i &gt; 0: left = self.VerifySquenceOfBST(sequence[:i]) right = True if j &lt; L - 1: right = self.VerifySquenceOfBST(sequence[i:L-1]) return left and right 24.二叉树中和为某一值的路径 Q：输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) A：前序遍历123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if root==None or root.val&gt;expectNumber: return [] if root.left==None and root.right==None and root.val==expectNumber: return [[root.val]] else: expectNumber -= root.val left = self.FindPath(root.left, expectNumber) right = self.FindPath(root.right, expectNumber) res = [] for x in left: res.append([root.val]+x) for x in right: res.append([root.val]+x) return sorted(res, key=lambda x: -len(x)) 25.复杂链表的复制 Q：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） A：三步走1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if pHead == None: return None pNode = pHead while pNode: # （1）在旧链表中创建新链表，此时不处理新链表的兄弟结点 pClone = RandomListNode(pNode.label) pClone.next = pNode.next pNode.next = pClone pNode = pClone.next pNode = pHead while pNode: # （2）根据旧链表的兄弟结点，初始化新链表的兄弟结点 pClone = pNode.next if pNode.random: pClone.random = pNode.random.next pNode = pClone.next pNode = pHead pCloneHead = pCloneNode = pNode.next pNode.next = pCloneHead.next pNode = pNode.next while pNode: # （3）从旧链表中拆分得到新链表（需保留旧链表） pCloneNode.next = pNode.next pCloneNode = pCloneNode.next pNode.next = pCloneNode.next pNode = pNode.next return pCloneHead 26.二叉搜索树与双向链表 Q：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 A：中序遍历：左根右1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Convert(self, pRootOfTree): # write code here if pRootOfTree == None: return None if pRootOfTree.left==None and pRootOfTree.right==None: return pRootOfTree self.Convert(pRootOfTree.left) # 左边 left = pRootOfTree.left if left: while left.right: # 左子树找到最大的结点（即最右边的） left = left.right pRootOfTree.left = left left.right = pRootOfTree self.Convert(pRootOfTree.right) right = pRootOfTree.right if right: while right.left: # 右子树找到最小的结点（即最左边的） right = right.left pRootOfTree.right = right right.left = pRootOfTree while pRootOfTree.left: pRootOfTree = pRootOfTree.left # 返回最左边的结点 return pRootOfTree 27.字符串的排列 Q：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 A：固定第一个元素，求后序所有字符的遍历，递归 或者 回溯法1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] res, charlist = [], list(ss) self.BackTrack(res, charlist, 0) return sorted(res) def BackTrack(self, res, charlist, begin): if begin == len(charlist) - 1: res.append("".join(charlist)) for i in range(begin, len(charlist)): if i!=begin and charlist[i] == charlist[begin]: continue charlist[i], charlist[begin] = charlist[begin], charlist[i] self.BackTrack(res, charlist, begin+1) charlist[i], charlist[begin] = charlist[begin], charlist[i]''' if len(ss) == 0: return [] if len(ss) == 1: return list(ss) charlist = list(ss) charlist.sort() res = [] for i in range(0, len(charlist)): if i&gt;0 and charlist[i] == charlist[i-1]: continue tmp = self.Permutation(''.join(charlist[:i]) + ''.join(charlist[i+1:])) for j in tmp: res.append(charlist[i] + j) return res''' 28.数组中出现次数超过一半的数字 Q：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 A：哈希表 或者 排序后中间的数字 或者 摩尔投票法【阵地攻守的思想】1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 num = numbers[0] cnt = 1 for i in range(1, len(numbers)): # 摩尔投票法 if cnt == 0: num = numbers[i] cnt = 1 elif numbers[i] == num: cnt += 1 else: cnt -= 1 cnt = 0 for i in range(0, len(numbers)): if numbers[i] == num: cnt += 1 return num if 2 * cnt &gt; len(numbers) else 0 29.最小的K个数 Q：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 A：大顶堆排序 或者 利用快排 pivot处在第k个位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here if len(tinput)==0 or k&lt;=0 or len(tinput)&lt;k: return [] start = 0 end = len(tinput) - 1 index = self.Partition(tinput, start, end) while index != k - 1: if index &gt; k - 1: end = index - 1 else: start = index + 1 index = self.Partition(tinput, start, end) return sorted(tinput[:k]) def Partition(self, arr, begin, end): # 划分元素 pivot = arr[begin] # 选取第一个元素作为基准 left = begin + 1 right = end while True: while left &lt;= right and arr[left] &lt;= pivot: left += 1 while left &lt;= right and arr[right] &gt;= pivot: right -= 1 if left &lt; right: arr[left], arr[right] = arr[right], arr[left] else: break arr[begin], arr[right] = arr[right], pivot # 划分元素放到中间位置 return right # 返回划分元素的下标''' for i in range(k/2-1, -1, -1): # 第k个元素的父结点 self.adjustMaxHeapSort(tinput, i, k-1) # 构建前k个元素的大顶堆（从后往前） for i in range(k, len(tinput)): # 只放前k个小的 if tinput[i] &lt; tinput[0]: tinput[i], tinput[0] = tinput[0], tinput[i] self.adjustMaxHeapSort(tinput, 0, k-1) # return sorted(tinput[:k]) return self.MaxHeapSort(tinput[:k]) def adjustMaxHeapSort(self, arr, pos, length): # 调整大顶堆（将最大值调整到根结点） tmp = arr[pos] while 2*pos+1 &lt;= length: child = 2 * pos + 1 if child&lt;length and arr[child]&lt;arr[child+1]: child += 1 if arr[child] &lt; tmp: break arr[pos] = arr[child] pos = child arr[pos] = tmp def MaxHeapSort(self, arr): if len(arr) == 0: return [] L = len(arr) for i in range(L/2-1, -1, -1): self.adjustMaxHeapSort(arr, i, L-1) for i in range(L-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] self.adjustMaxHeapSort(arr, 0, i-1) return arr''' 30.连续子数组的最大和 Q：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) A：动态规划 或者 分析规律求解过程1234567891011121314151617181920212223242526272829303132333435363738# f(i)表示：以array[i]为末尾元素的子数组 的和的最大值# -*- coding:utf-8 -*-'''f(i) = arr[i] , i = 0 或者 f(i-1) &lt; 0f(i) = f(i-1) + arr[i], i != 0 并且 f(i-1) &gt; 0'''class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 pre = array[0] res = array[0] # 已知的最大值 for i in range(1, len(array)): cur = max(pre + array[i], array[i]) # f(i)=max(f(i-1)+arr[i], arr[i]) res = max(cur, res) pre = cur return res''' cur_sum = 0 max_sum = array[0] for i in range(len(array)): if cur_sum &lt;= 0: cur_sum = array[i] else: cur_sum += array[i] if cur_sum &gt; max_sum: max_sum = cur_sum return max_sum''' 31.整数中1出现的次数（从1到n整数中1出现的次数） Q：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 A：常规方法 %101234567891011# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here cnt = 0 for i in range(1, n+1): while i: if i%10 == 1: cnt += 1 i = i / 10 return cnt 32.把数组排成最小的数 Q：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 A：排序12345678910111213# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' str_num = [str(i) for i in numbers] for i in range(len(str_num)-1): # 选择排序 for j in range(i+1, len(str_num)): if str_num[i]+str_num[j] &gt; str_num[j]+str_num[i]: str_num[i], str_num[j] = str_num[j], str_num[i] return "".join(str_num) 33.丑数 Q：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 A：12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt; 0: return None if index &lt; 7: return index p2, p3, p5 = 0, 0, 0 new_num = 1 arr = [1] while len(arr) &lt; index: # 下一个丑数是前面的某一个丑数乘以235得到的 new_num = min(arr[p2]*2, arr[p3]*3, arr[p5]*5) if arr[p2]*2 == new_num: p2 += 1 if arr[p3]*3 == new_num: p3 += 1 if arr[p5]*5 == new_num: p5 += 1 arr.append(new_num) return new_num 34.第一个只出现一次的字符位置 Q：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. A：12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 hash_table = &#123;&#125; for i in s: if i not in hash_table: hash_table[i] = 0 hash_table[i] += 1 for i in s: if hash_table[i] == 1: return s.index(i) return -1 35.数组中的逆序对 Q：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 A：123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; return mergeSort(data, 0, data.size()-1); &#125; int mergeSort(vector&lt;int&gt; &amp;data, int start, int end) &#123; if (start &gt;= end) return 0; int mid = (start + end)/2; int left_num = mergeSort(data, start, mid); int right_num = mergeSort(data, mid+1, end); vector&lt;int&gt; copy(data); int i = mid, j = end, k = end; int cnt = 0; while (i&gt;=start &amp;&amp; j&gt;=mid+1) // 从高位向低位归并 &#123; if (data[i] &gt; data[j]) // 比最大的还大，加上右边数组长度 &#123; copy[k--] = data[i--]; cnt += j - mid; &#125; else copy[k--] = data[j--]; &#125; while (i&gt;=start) copy[k--] = data[i--]; while (j&gt;=mid+1) copy[k--] = data[j--]; for (int i=start; i&lt;=end; i++) data[i] = copy[i]; return (left_num + cnt + right_num)%1000000007; &#125;&#125;; 36.两个链表的第一个公共结点 Q：输入两个链表，找出它们的第一个公共结点。 A：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here if pHead1==None or pHead2==None: return None L1, L2 = 0, 0 p1, p2 = pHead1, pHead2 while p1: L1 += 1 p1 = p1.next while p2: L2 += 1 p2 = p2.next p1, p2 = pHead1, pHead2 if L1 &gt; L2: k = L1 - L2 while k: p1 = p1.next k -= 1 elif L1 &lt; L2: k = L2 - L1 while k: p2 = p2.next k -= 1 while p1: if p1 is p2: return p1 p1 = p1.next p2 = p2.next return None 37.数字在排序数组中出现的次数 Q：统计一个数字在排序数组中出现的次数。 A：12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 if k &lt; data[0] or k &gt; data[-1]: return 0 left = 0 right = len(data) - 1 while left &lt;= right: mid = (left + right) / 2 if data[mid] &lt; k: left = mid + 1 else: right = mid - 1 first = left # 如果没有k，a &lt; k &lt; b，left在b的位置 left = 0 right = len(data) - 1 while left &lt;= right: mid = (left + right) / 2 if data[mid] &gt; k: right = mid - 1 else: left = mid + 1 last = right # 如果没有k，a &lt; k &lt; b，right在a的位置 return last - first + 1 38.二叉树的深度 Q：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 A：123456789101112# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def TreeDepth(self, pRoot): # write code here if pRoot == None: return 0 return 1 + max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right)) 39.平衡二叉树 Q：输入一棵二叉树，判断该二叉树是否是平衡二叉树。 A：12345678910111213141516171819# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 def IsBalanced_Solution(self, pRoot): # write code here if pRoot == None: return True return abs(self.get_depth(pRoot.left) - self.get_depth(pRoot.right))&lt;=1 and \ self.IsBalanced_Solution(pRoot.left) and \ self.IsBalanced_Solution(pRoot.right) def get_depth(self, pRoot): if pRoot == None: return 0 return 1 + max(self.get_depth(pRoot.left), self.get_depth(pRoot.right)) 40.数组中只出现一次的数字 Q：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字 A：1234567891011121314151617# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here hash_ = &#123;&#125; for i in array: if i not in hash_: hash_[i] = 0 hash_[i] += 1 res = [] for i in hash_: if hash_[i] == 1: res.append(i) if len(res) == 2: break return res 41.和为S的连续正数序列 Q：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!【输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序】 A：123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here res = [] plow, phigh = 1, 2 # 双指针操作 while plow &lt; phigh: cur = (plow + phigh) * (phigh - plow + 1) / 2 # 等差数列求和 if cur == tsum: tmp = list(range(plow, phigh+1)) res.append(tmp) plow += 1 elif cur &lt; tsum: phigh += 1 else: plow += 1 return res 42.和为S的两个数字 Q：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 A：1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array) &lt; 2: return [] plow, phigh = 0, len(array)-1 while plow &lt; phigh: if array[plow] + array[phigh] == tsum: # a和b越远乘积越小，a*(k-a) return [array[plow], array[phigh]] elif array[plow] + array[phigh] &gt; tsum: phigh -= 1 else: plow += 1 return [] 43.左旋转字符串 Q：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ A：12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if n &lt; 0: return "" if len(s) == 0: return "" m = n % len(s) stack = list(s) self.Reverse(stack, 0, m-1) # YX= (X^T Y^T)^T self.Reverse(stack, m, len(s)-1) self.Reverse(stack, 0, len(s)-1) return "".join(stack) def Reverse(self, arr, start, end): while start &lt; end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1''' for i in range(n%len(s)): # 队列操作 tmp = stack.pop(0) stack.append(tmp) return "".join(stack)''' 44.翻转单词顺序列 Q：牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ A：1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if len(s) == 0: return '' stack = list(s) self.Reverse(stack, 0, len(s)-1) # 先逆置 head, cur = 0, -1 while cur &lt; len(s): if cur == len(s)-1 or stack[cur+1] == ' ': self.Reverse(stack, head, cur) # 按空格区分，逆置单词 cur += 2 head = cur else: cur += 1 return "".join(stack) def Reverse(self, arr, start, end): while start &lt; end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 45.扑克牌顺子 Q：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 A：1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) &lt; 5: return False min_v = 14 max_v = -1 cnt = &#123;&#125; for i in numbers: if i == 0: # 除0外没有重复的数字(牌) continue if i in cnt: return False else: cnt[i] = 1 if i &gt; max_v: max_v = i if i &lt; min_v: min_v = i if max_v - min_v &lt; 5: # max - min &lt;5 return True else: return False 46.孩子们的游戏(圆圈中最后剩下的数) Q：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) A：12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n == 0: return -1 res = 0 for i in range(2, n+1): res = (res + m) % i return res'''f(n,m)： 0 1 2 ... n-3 n-2 n-1 【n个数】每次删除后的最终结果f(n-1,m)： 0 1 2 ... n-3 n-2 【n-1个数】每次删除后的最终结果0 1 2 ... k-1 k+1 ... n-2 n-1 删除k，k=m-1g(n-1,m)： k+1 k+2 ... n-2 n-1 0 1 2 ... k-2 k-1 【n-1个数】f(n,m) = g(n-1,m) = (f(n-1,m)+k+1)%n递归公式：f(1, m) = 0f(n, m) = (f(n-1, m) + m) % n''' 47.求1+2+3+…+n Q：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 A：1234567# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here 利用逻辑与的短路特性实现递归终止 return n and self.Sum_Solution(n - 1) + n # 利用python中的and特性，a and b，a为False，返回a，a为True，就返回b 48.不用加减乘除做加法 Q：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 A：12345678910# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here while num2 != 0: tmp = (num1 ^ num2) &amp; 0xffffffff # 异或 两个数异或：相当于每一位相加，而不考虑进位 carry = ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xffffffff # 两个数相与，并左移一位：相当于求得进位 num1 = tmp num2 = carry return num1 if num1 &lt;= 0x7fffffff else ~(num1^0xffffffff) 49.把字符串转换成整数 Q：将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 A：12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if len(s) == 0: return 0 numdict = &#123;'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8,'9':9&#125; res = [] for i in range(len(s)): if i==0 and (s[i]=='+' or s[i]=='-'): continue if s[i] not in numdict: return 0 else: res.append(numdict[s[i]]) v = 0 for j in range(len(res)): v = v * 10 + res[j] return 0-v if s[0] == '-' else v 50.数组中重复的数字 Q：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 A：12345678910111213141516# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here n = len(numbers) for i in range(n): index = numbers[i] if index &gt;= n: index -= n if numbers[index] &gt;= n: duplication[0] = index return True numbers[index] += n return False 51.构建乘积数组 Q：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 A：12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here # 前一部分 C[i] = A[0]*A[1]*...*A[i-1] = C[i-1]A[i-1] # 后一部分 D[i] = A[i+1]*A[i+2]*...*A[n-1] = A[i+1]D[i+1] if len(A) == 0: return [] B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1] * A[i-1] tmp = 1 for i in range(len(A)-2, -1, -1): tmp *= A[i+1] B[i] *= tmp return B 52.正则表达式匹配 Q：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 A：12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): # write code here if s=='' and pattern=='': return True elif s!='' and pattern=='': return False elif s=='' and pattern!='': if len(pattern)&gt;1 and pattern[1]=='*': return self.match(s, pattern[2:]) else: return False else: if len(pattern)&gt;1 and pattern[1]=='*': if s[0]!=pattern[0] and pattern[0]!='.': return self.match(s, pattern[2:]) else: # 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况 return self.match(s, pattern[2:]) or \ self.match(s[1:], pattern[2:]) or \ self.match(s[1:], pattern)# pattern前两位是空、# pattern前两位与s[0]匹配、# pattern前两位与s中多个匹配 else: if s[0]==pattern[0] or pattern[0]=='.': return self.match(s[1:], pattern[1:]) else: return False 53.表示数值的字符串 Q：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 A：123456789101112# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here t = "0123456789.+-Ee" valid = '' power = '' for i in t: if i not in t: return False 54.字符流中第一个不重复的字符 Q：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。【如果当前字符流没有存在出现一次的字符，返回#字符。】 A：1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dict_ = &#123;&#125; self.list_ = [] # 返回对应char def FirstAppearingOnce(self): # write code here if len(self.list_) == 0: return '#' for i in self.list_: if self.dict_[i] == 1: return i return '#' def Insert(self, char): # write code here if char not in self.dict_: self.dict_[char] = 1 self.list_.append(char) else: self.dict_[char] += 1 55.链表中环的入口结点 Q：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 A：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def EntryNodeOfLoop(self, pHead): # write code here if pHead == None or pHead.next == None: return None p1 = p2 = pHead # 找相遇结点 while p1!=None and p2.next!=None: p1 = p1.next p2 = p2.next.next if p1 == p2: # 找相遇结点 break if p2 == None or p2.next == None: return None meet = p1 # p1 现在是相遇结点 n = 1 # 记录环里面结点的个数 while p1.next != meet: n += 1 p1 = p1.next p1 = p2 = pHead while n &gt; 0: p2 = p2.next n -= 1 while p1 != p2: # p2正好多走了一圈 p1 = p1.next p2 = p2.next return p1''' dic = &#123;&#125; tmp = pHead while tmp: if tmp not in dic: dic[tmp] = 1 else: return tmp tmp = tmp.next return None''' 56.删除链表中重复的结点 Q：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 A：12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplication(self, pHead): # write code here if pHead == None or pHead.next == None: return pHead newHead = ListNode(-1) # 设置一个trick newHead.next = pHead last = newHead # 当前结点的上一个结点 while pHead and pHead.next: if pHead.val == pHead.next.val: tmp = pHead.next.val while pHead and tmp == pHead.val: pHead = pHead.next last.next = pHead else: last = pHead pHead = pHead.next return newHead.next 57.二叉树的下一个结点 Q：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 A：123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = None # 父节点class Solution: def GetNext(self, pNode): # write code here if pNode == None: return None if pNode.right: # 有右子树，下一个是右子树最左边的结点 pNode = pNode.right while pNode.left: pNode = pNode.left return pNode elif pNode.next and pNode.next.left == pNode: # 没有右子树，有父节点，是父节点的左子树 return pNode.next elif pNode.next and pNode.next.right == pNode: # 没有右子树，有父节点，是父节点的右子树 pNode = pNode.next while pNode.next and pNode.next.right==pNode: # 沿右侧往上找 pNode = pNode.next if pNode.next: return pNode.next else: return None 58.对称的二叉树 Q：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 A：12345678910111213141516171819202122232425# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if pRoot == None: return True else: return self.Mirror(pRoot.left, pRoot.right) def Mirror(self, root1, root2): # write code here if root1 == None and root2 == None: return True elif root1 != None and root2 != None: return root1.val == root2.val and \ self.Mirror(root1.left, root2.right) and \ self.Mirror(root1.right, root2.left) else: return False 59.按之字形顺序打印二叉树 Q：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 A：引用两个队列，分别存储当前行和下一行12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if pRoot == None: return [] res, nodes = [], [pRoot] is_odd = True # 是奇数 while len(nodes): curStack, nextStack = [], [] for i in nodes: curStack.append(i.val) if i.left: nextStack.append(i.left) if i.right: nextStack.append(i.right) if not is_odd: # 偶数行是逆序 curStack = curStack[::-1] res.append(curStack) nodes = nextStack is_odd = not is_odd # 下一行取反 return res 60.把二叉树打印成多行 Q：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 A：引入队列，与22题不同的是用二维列表分层放结果1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if pRoot == None: return [] res, nodes = [], [pRoot] while len(nodes): cur, next_ = [], [] for i in nodes: cur.append(i.val) if i.left: next_.append(i.left) if i.right: next_.append(i.right) res.append(cur) nodes = next_ return res 61.序列化二叉树 Q：请实现两个函数，分别用来序列化和反序列化二叉树 A：12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def __init__(self): self.index = -1 def Serialize(self, root): # write code here if root == None: return '#,' return str(root.val) + ',' + \ self.Serialize(root.left) + \ self.Serialize(root.right) def Deserialize(self, s): # write code here self.index += 1 s_list = s.split(',') if self.index &gt; len(s_list): return None if s_list[self.index] != '#': root = TreeNode(int(s_list[self.index])) root.left = self.Deserialize(s) root.right = self.Deserialize(s) return root else: return None 62.二叉搜索树的第k个结点 Q：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 A：中序遍历，输出第k个123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode 左 &lt; 根 &lt; 右 def __init__(self): self.n = 0 def KthNode(self, pRoot, k): # write code here if k &lt;= 0: return None if pRoot: node = self.KthNode(pRoot.left, k) if node: # 必须要对递归的返回值做判断 return node self.n += 1 if self.n == k: return pRoot # 访问 node = self.KthNode(pRoot.right, k) if node: return node return None 63.数据流中的中位数 Q：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 A：123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def __init__(self): self.digit = [] def Insert(self, num): # write code here self.digit.append(num) for i in range(len(self.digit)-1, 0, -1): if self.digit[i] &lt; self.digit[i-1]: self.digit[i], self.digit[i-1] = self.digit[i-1], self.digit[i] def GetMedian(self, n=None): # write code here if len(self.digit) == 0: return None if len(self.digit) % 2 == 1: mid = (len(self.digit)-1) / 2 return self.digit[mid] else: right = len(self.digit) / 2 left = right - 1 return (self.digit[left] + self.digit[right]) / 2.0 64.滑动窗口的最大值 Q：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 A：1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num)==0 or size&lt;=0 or len(num) &lt; size: return [] res = [] DeQueue_index = [] # 双端队列存储下标index, 队头放最大值 for i in range(size): # 4 while len(DeQueue_index) and num[i]&gt;num[DeQueue_index[-1]]: DeQueue_index.pop() # 新元素k，队尾里面比k小的移出，不可能成为最大值 DeQueue_index.append(i) for i in range(size, len(num)): res.append(num[DeQueue_index[0]]) while len(DeQueue_index) and num[i]&gt;num[DeQueue_index[-1]]: DeQueue_index.pop() if len(DeQueue_index) and DeQueue_index[0]&lt;=i-size: # 队头过期 DeQueue_index.pop(0) # 窗口范围 [i-size+1, i] DeQueue_index.append(i) res.append(num[DeQueue_index[0]]) return res 65.矩阵中的路径 Q：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 A：123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here 回溯法 if matrix==None or rows&lt;1 or cols&lt;1 or path==None: return False visited = [0] * rows * cols pathLength = 0 for row in range(rows): for col in range(cols): if self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited): return True return False # 判断：matrix[row, col] == path[pathLength] ？ def hasPathCore(self, matrix, rows, cols, row, col, path, pathLength, visited): if len(path) == pathLength: return True has_path = False if 0&lt;=row&lt;rows and 0&lt;=col&lt;cols and matrix[row*cols + col]==path[pathLength] and \ not visited[row*cols + col]: pathLength += 1 visited[row*cols + col] = True has_path = self.hasPathCore(matrix, rows, cols, row, col-1, path, pathLength, visited) or \ self.hasPathCore(matrix, rows, cols, row-1, col, path, pathLength, visited) or \ self.hasPathCore(matrix, rows, cols, row, col+1, path, pathLength, visited) or \ self.hasPathCore(matrix, rows, cols, row+1, col, path, pathLength, visited) if not has_path: pathLength -= 1 visited[row*cols + col] = False return has_path 66.机器人的运动范围 Q：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ A：12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here visited = [0] * rows * cols return self.movingCountCore(threshold, rows, cols, 0, 0, visited) def movingCountCore(self, threshold, rows, cols, row, col, visited): cnt = 0 if 0&lt;=row&lt;rows and 0&lt;=col&lt;cols and self.get_num(row, col)&lt;=threshold \ and not visited[row*cols+col]: visited[row*cols+col] = True cnt = 1 + self.movingCountCore(threshold, rows, cols, row-1, col, visited) + \ self.movingCountCore(threshold, rows, cols, row+1, col, visited) + \ self.movingCountCore(threshold, rows, cols, row, col-1, visited) + \ self.movingCountCore(threshold, rows, cols, row, col+1, visited) return cnt def get_num(self, row, col): tmp = str(row) + str(col) s = 0 for i in tmp: s += int(i) return s]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>笔试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code 使用教程]]></title>
    <url>%2F2019%2F11%2F09%2Fvscode%2F</url>
    <content type="text"><![CDATA[[TOC] VS Code 文档 快捷键 官方速查表 VScode快捷键（最全） 展示命令面板：Ctrl+Shift+P, F1 打开用户设置：Ctrl+, 打开键盘快捷: Ctrl+K Ctrl+S 折叠所有区域：Ctrl+K Ctrl+0 展开所有子域：Ctrl+K Ctrl+] 新建窗口：Ctrl+Shift+N 拆分编辑：Ctrl+\ 转到某行：Ctrl+G 转到文件：Ctrl+P 返回/前进：Alt+ ←/→ 复制当前行：Ctrl+C 剪切当前行：Ctrl+X 查找：Ctrl+F 替换：Ctrl+H 插入多个光标：Alt + Click 列选择：Shift+Alt+Click 文档格式化：Shift+Alt+F 重命名符号：F2 放大/缩小：Ctrl + = / - 打开终端：`Ctrl+`` Debug 开始/暂停：F5 Debug 下一步：F11 Debug 上一步：Shift+F11 Debug 跳过：F10 Debug 切换断点：F9 插件 PYTHON开发利器之VS Code 常用插件介绍 VS Code 必备插件推荐 30个极大提高开发效率的Visual Studio Code插件 VS Code 插件推荐合集（持续更新） 超实用VS Code插件推荐——不定期更新！ 插件离线安装在服务器 离线安装 VSCode Remote-SSH 简单的 VSCode 插件离线安装方法 利用 Settings Sync 同步vs code配置 VSCode 云同步扩展设置 Settings Sync 插件 1234gist.github.com 无法访问解决办法windows下 打开C:\Windows\System32\drivers\etc\hosts文件 编辑器打开，在最后行添加192.30.253.118 gist.github.com Personal access tokens：****4606e10869db482c04**** 12345ctrl + p&gt;sync高级选项编辑扩展本地设置&quot;token&quot;: 复制粘贴 创建的Gist仓库的ID：****2a9c160ee35e**** 12插件名右击选择【配置扩展设置】【设置同步使用的 GitHub Gist ID】复制粘贴 VScode Remote ssh VSCode:Remote-SSH配置实录 VSCode远程编辑,Remote-SSH,Remote Development VScode Remote ssh ==离线安装==服务器 报错解决：Downloading VS Code Server failed. Please try again later. vscode搭建远程开发123456789101112# remote-ssh 连接，失败后，点击查看细节# 终端输入命令，查看链接，手动下载ps -aux | grep vscode wget -nv -O vscode-server-linux-x64.tar.gzhttps://update.code.visualstudio.com/commit:2213894ea0415ee8c85c5eea0d0ff81ecc191529/server-linux-x64/stable# 安装cd ~/.vscode-server/bin/*/tar -zxvf vscode-server-linux-x64.tar.gz -C ./mv vscode-server-linux-x64/* .touch 0 配置git 如何给VScode配置git Git+VSCode基本使用 Visual Studio Code第二弹：Vscode与Git的完美结合 Code Server — VSCODE 服务器版（不太好用） Code Server — VSCODE 服务器版 （推荐）VS code在线工具——code-serve 在云服务器上的安装和使用 与常见的问题解决 (超详细) VSCode下C/C++环境配置 https://blog.csdn.net/danxibaoxxx/article/details/81289651 KoroFileHeader 文件头、函数头注释 https://blog.csdn.net/sueRimn/article/details/88048276]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix 安装和配置]]></title>
    <url>%2F2019%2F09%2F27%2Fzabbix%2F</url>
    <content type="text"><![CDATA[[TOC] 相关链接 官网：https://www.zabbix.com/download Ubuntu 安装 Zabbix 3 详细步骤 在 Ubuntu 16.04 Server 上安装 Zabbix Zabbix 系列博客教程目录 Linux Dash Ubuntu Server 14.04 安装状态监控Linux Dash 如何在Ubuntu 14.04安装 Linux Dash https://github.com/NoBey/linux-dash-zh ubuntu 下卸载 mysql8 linux服务器监控工具 每个系统管理员都要知道的 30 个 Linux 系统监控工具 你值得拥有 —— 25 个 Linux 性能监控工具 80 多个 Linux 系统管理员必备的监控工具 zabbix 自动化运维工具1、平台和环境1234ZABBIX VERSION: 3.0 LTSOS DISTRIBUTION: UbuntuOS VERSION: 16.04 (Xenial)DATABASE: MySQL (5.x，非8.x) 2、安装和配置服务端（server）Ⅰ、安装仓库（repository）123wget https://repo.zabbix.com/zabbix/3.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.0-2+xenial_all.debsudo dpkg -i zabbix-release_3.0-2+xenial_all.debsudo apt update Ⅱ、安装服务端、前端、客户端（server, frontend, agent）1sudo apt -y install zabbix-server-mysql zabbix-frontend-php zabbix-agent Ⅲ、数据库初始化12345678910sudo apt-get install mysql-server # 若没有安装 mysql5.xmysql -uroot -p输入root用户的 passwordmysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix';mysql&gt; quit;# 导入初始模式和数据zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix输入密码：zabbix # 要等一会儿，不能强行中断 Ⅳ、服务端配置数据库123sudo vim /etc/zabbix/zabbix_server.conf# 修改DBPassword=zabbix Ⅴ、配置PHP时区1234567sudo vim /etc/zabbix/apache.conf# 修改php_value date.timezone Asia/Shanghaisudo vim /etc/php/7.0/apache2/php.ini# 修改date.timezone = Asia/Shanghai Ⅵ、启动、重启、停止、开机运行服务123456789sudo service zabbix-server startsudo service zabbix-server stopsudo service zabbix-server restartsudo service apache2 startsudo service apache2 stopsudo service apache2 restart # 重启apachesudo netstat -ntpl | grep zabbix # 查看进程sudo update-rc.d zabbix-server enable # 开机运行vim /etc/rc0.d/ # 查看是否有zabbix设置为开机自启动 Ⅶ、日志/var/log/zabbix/zabbix_server.log 3、web前端Ⅰ、安装 浏览器中输入：http://&lt;server_ip_or_name&gt;/zabbix 欢迎界面：Welcome to Zabbix 3.0 点击“Next step”后会出现校验配置页面 右侧均为“OK”说明配置正确生效，如果有红叉则需要查看之前相应的修改配置项。 点击“Next step”后会出现配置数据库连接界面 “Password”处填写“zabbix” 点击“Next step”后出现 zabbix 服务器信息界面 在“Name”处填写“zabbix” 点击“Next step”后会展示之前安装的配置项，再次点击“Next step”即可进入安装。 安装完成后点击“Finish”。 登陆 zabbix web， 初始登陆用户名为“Admin”，密码为“zabbix”。 Ⅱ、设置中文界面 首先点击 web 界面右上角的用户头像 然后进入“User”设置项，在“Language”处修改为“Chinese（zh_CN）”，然后点击“Update”跟新即可 12若不能选择 Chinese（zh_CN），安装中文环境 locale -asudo apt-get install language-pack-zh-hant language-pack-zh-hans Ⅲ、添加中文字体（解决中文全是方格问题）12345678910cd /etc/nginx/html/zabbix/fonts/ # 进入目录存放字体文件DejaVuSans.ttf # 仿宋简体-常规sudo vim /usr/share/zabbix/include/locales.inc.php# 修改'zh_CN' =&gt; ['name' =&gt; _('Chinese (zh_CN)'), 'display' =&gt; true],sudo vim /usr/share/zabbix/include/defines.inc.php # 修改文件中字体的配置define('ZBX_GRAPH_FONT_NAME', 'DejaVuSans'); # 指定字体文件名 4、客户端123456789101112131415sudo apt -y install zabbix-agentsudo service zabbix-agent startsudo service zabbix-agent stopsudo service zabbix-agent restartsudo netstat -ntpl | grep zabbixsudo service zabbix-agent statussudo update-rc.d zabbix-agent enable # 开机启动# 修改配置文件sudo vi /etc/zabbix/zabbix_agentd.confServer=192.168.126.122 # 接受数据的服务端ipServerActive=192.168.126.122 # 接受数据的服务端ipHostname=192.168.126.139 # 当前服务器的ip 5、添加监控Ⅰ、基本 zabbix监控第一台服务器（10） Zabbix分布式监控系统实践 自定义配置 zabbix添加监控服务器. 创建主机，成功后，可以看到对应的Host，但右侧不会显示绿色的被监控图标，因为目前还没有配置任何监控选项 主机名必须和上面的Hostname一致！ Ⅱ、监控多个GPU https://github.com/plambe/zabbix-nvidia-smi-multi-gpu/ 修改文件 123456789101112sudo vim /etc/zabbix/zabbix_agentd.conf# 复制 userparameter_nvidia-smi.conf.linux 文件里面的内容至文件末尾UserParameter=gpu.number,/usr/bin/nvidia-smi -L | /usr/bin/wc -lUserParameter=gpu.discovery,/etc/zabbix/scripts/get_gpus_info.shUserParameter=gpu.fanspeed[*],nvidia-smi --query-gpu=fan.speed --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.power[*],nvidia-smi --query-gpu=power.draw --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.temp[*],nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.utilization[*],nvidia-smi --query-gpu=utilization.gpu --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.memfree[*],nvidia-smi --query-gpu=memory.free --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.memused[*],nvidia-smi --query-gpu=memory.used --format=csv,noheader,nounits -i $1 | tr -d "\n"UserParameter=gpu.memtotal[*],nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits -i $1 | tr -d "\n" 复制脚本，设置可执行 12345cd /etc/zabbix/sudo mkdir scriptscd scripts/sudo cp /data4/zzk/get_gpus_info.sh ./sudo chmod +x get_gpus_info.sh web端导入模板文件：zbx_nvidia-smi-multi-gpu.xml 6、普通用户Ⅰ、新建 【管理】→【用户】→【创建用户】→【别名】→【群组-选择普通用户】→【密码】→【密码确认】→【语言-中文】→【添加】 Ⅱ、赋予权限 【监测中】→【聚合图形】→【xx名称-动作-属性】→【分享】→【用户组共享列表-添加普通用户】→【用户共享列表- 添加用户名】→【更新】]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GPU</tag>
        <tag>软件</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 使用教程]]></title>
    <url>%2F2019%2F09%2F07%2Fanaconda%2F</url>
    <content type="text"><![CDATA[[TOC] 相关链接 官网：https://www.anaconda.com/ 下载安装包：https://www.anaconda.com/distribution/ 清华镜像 Miniconda Anaconda详细安装及使用教程 一、Anaconda3 安装与卸载Linux 安装1234567891011121314151617# 依次输入以下命令wget https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh # 等待下载完成bash Anaconda3-5.1.0-Linux-x86_64.sh # 调用shell程序ENTER # 按回车键q # 输入q，不用按回车键yes # 输入yes，按回车键ENTER # 等待安装完成yes # 输入yes，添加环境变量到当前用户目录下# 下一步不用输入 yes，直接重新打开 Linux 终端，当前用户根的目录下会有一个 anaconda3/ 目录# 测试是否已安装好 Anaconda 3，输入 python 按回车键会显示如下信息：Python 3.6.4 |Anaconda, Inc.| (default, Jan 16 2018, 18:10:19)[GCC 7.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;# 再输入 exit()，按回车键退出 python 环境 1rm -rf ~/anaconda3 # 卸载anaconda Windows 安装 安装exe文件时，注意点击添加环境变量，否则手动配置123F:\Anaconda3F:\Anaconda3\ScriptsF:\Anaconda3\Library\bin 二、包管理12345678910111213141516171819202122# 设置镜像：conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# 显示来源：conda config --set show_channel_urls yesconda configvim ~/.condarcchannels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/rcustom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 123456789conda list 列举当前环境下的所有包conda list -n packagename 列举某个特定名称包conda install packagename 为当前环境安装某包conda install -n envname packagename 为某环境安装某包conda search packagename 搜索某包conda updata packagename 更新当前环境某包conda update -n envname packagename 更新某特定环境某包conda remove packagename 删除当前环境某包conda remove -n envname packagename 删除某环境环境某包 三、虚拟环境基本命令 查看：conda env list 或 conda info -e 或 conda info --envs 创建：conda create -n env_name python=3.6 同时安装多个包：conda create -n env_name numpy matplotlib python=2.7 再额外安装包：conda install -n env_name [package] 激活(Linux)：source activate env_name 激活(Windows)：activate env_name 或 conda activate env_name 关闭(Linux)：source deactivate 关闭(Windows)：deactivate 或 conda deactivate 删除包：conda remove -n env_name [package] 删除环境：conda remove -n env_name --all 导出环境：conda env export &gt; environment.yaml 导入环境(先激活)：conda env update -f=environment.yml 复制克隆：conda create --name &lt;new_env&gt; --clone &lt;old_env&gt; Jupyter 中使用 conda 虚拟环境 jupyter中添加conda环境—-kernel配置 1、激活环境：source activate env_name 2、安装 ipykernel：conda install -n env_name ipykernel 3、将环境写入 notebook 的 kernel 中：python -m ipykernel install --user --name env_name --display-name env_name 4、删除 kernel：jupyter kernelspec remove env_name 5、在激活的虚拟环境中打开：jupyter notebook 四、Windows 下实际操作12345678910111213141516conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yesconda create -n tf1.13 python=3.6conda install -n tf1.13 tensorflow=1.13 # CPU版conda install -n tf1.13 tensorflow-gpu=1.13 # GPU版conda install -n tf1.13 scikit-learnconda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=9.2 -c pytorch # CUDA 9.2conda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=10.0 -c pytorch # CUDA 10.0conda install pytorch==1.2.0 torchvision==0.4.0 cpuonly -c pytorch # CPU Onlysource activate tf1.13conda install -n tf1.13 ipykernelpython -m ipykernel install --user --name tf1.13 --display-name tf1.13 五、pip 配置镜像 国内镜像 临时使用： 可以在使用pip的时候在后面加上-i参数，指定pip源pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simplepip install numpy -i https://pypi.mirrors.ustc.edu.cn/simple 永久修改：1234567891011121314@ Linuxmkdir ~/.pipcd ~/.pipvim pip.conf@ WindowsC:\Users\你的用户名\pip\pip.ini例：C:\Users\Administrator\pip\pip.ini文件内容：[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=pypi.tuna.tsinghua.edu.cn]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>Python</tag>
        <tag>虚拟环境</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook 使用教程]]></title>
    <url>%2F2019%2F09%2F07%2Fjupyter%2F</url>
    <content type="text"><![CDATA[[TOC] 相关链接 Jupyter notebook远程访问服务器的方法 远程连接服务器jupyter notebook、浏览器以及深度学习可视化方法 远程访问jupyter notebook jupyter notebook启动出错解决方法 【推荐】最详尽使用指南：超快上手Jupyter Notebook 修改主题： https://github.com/dunovank/jupyter-themes 安装插件：https://github.com/ipython-contrib/jupyter_contrib_nbextensions 一、Jupyter Notebook安装12python -m pip install jupyter # 先检查，后安装jupyter notebook --generate-config # 记录生成的文件 密码1234567python # 命令行from notebook.auth import passwdpasswd()Enter password: # 输入密码Verify password: # 验证密码Out[2]: 'sha1:ce23dxxxxxxxxxx' # 复制密文 配置 打开上面生成的文件 vim ~/.jupyter/jupyter_notebook_config.py123456# 在文件最后面添加：c.NotebookApp.ip=&apos;*&apos; # 也可以指定具体 ipc.NotebookApp.password = u&apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = False # 禁止自动打开浏览器c.NotebookApp.port = 8888 # 随便指定一个端口c.InteractiveShellApp.matplotlib = &apos;inline&apos; # 显示Matplotlib的图形 打开 在指定目录打开cmd或者命令行，输入：jupyter notebook 浏览器输入地址：localhost:8888 二、插件安装123python -m pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --userjupyter nbextension enable codefolding/main 配置 重新打开jupyter，刷新首页，点击：Nbextensions，选择插件 非正常情况下：http:ip地址:8888/nbextensions?nbextension=codefolding/main 12345Codefolding # 折叠标题Collapsible headings # 折叠代码ExecuteTime # 执行时间Notify # 发送通知Table of Contents # 自动生成目录 三、输入命令 在命令前加一个英文感叹号：! 例如：! cd data_dir/]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn 之 文本分类（特征提取、选择、评估）]]></title>
    <url>%2F2019%2F08%2F31%2Fsklearn_cls%2F</url>
    <content type="text"><![CDATA[相关链接 英文官网：https://scikit-learn.org/stable/ 中文官网：https://sklearn.apachecn.org/ 官网翻译1、官网翻译2 ML神器：sklearn的快速使用 【scikit-learn】01~07 python + sklearn ︱分类效果评估——acc、recall、F1、ROC、回归、距离 【ZH奶酪】如何用sklearn计算中文文本TF-IDF？ sklearn中CountVectorizer里token_pattern默认参数解读 tfidf_CountVectorizer 与 TfidfTransformer 保存和测试 sklearn训练后使用pickle、joblib保存与恢复模型 分类器、指标、特征提取、特征选择123456789101112131415161718192021222324252627282930313233343536import jsonimport numpy as npimport warningswarnings.filterwarnings('ignore')from sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import TfidfTransformerfrom sklearn import metricsfrom sklearn.naive_bayes import GaussianNBfrom sklearn.naive_bayes import MultinomialNBfrom sklearn.linear_model import LogisticRegressionfrom sklearn.linear_model import SGDClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.tree import ExtraTreeClassifierfrom sklearn.neural_network import MLPClassifierfrom sklearn.neural_network import BernoulliRBMfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.neighbors import RadiusNeighborsClassifierfrom sklearn.svm import SVCfrom sklearn.svm import LinearSVCfrom sklearn.svm import libsvmfrom sklearn.ensemble import AdaBoostClassifierfrom sklearn.ensemble import BaggingClassifierfrom sklearn.ensemble import ExtraTreesClassifierfrom sklearn.ensemble import GradientBoostingClassifierfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.ensemble import VotingClassifierfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDAfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDAfrom xgboost import XGBClassifierfrom sklearn.feature_selection import SelectKBestfrom sklearn.feature_selection import SelectPercentilefrom sklearn.feature_selection import chi2 数据处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def read_file(filename): all_data, all_tag = [], [] with open(filename, 'r', encoding='utf-8') as fr: for line in fr: row = json.loads(line) all_data.append(row["question"]) all_tag.append(row["Coarse"]) return all_data, all_tagdef get_train_test(): train_file = './QC/data/问题集/trainquestion.json' test_file = './QC/data/问题集/testquestion.json' x_train, y_train = read_file(train_file) x_test, y_test = read_file(test_file) return x_train, y_train, x_test, y_testdef get_ngram_seg(sen, n): ngram_list = [] for i in range(len(sen)): if i + n &lt;= len(sen): ngram_list.append(sen[i: i+n]) return ngram_listdef get_seg(DATA): # return [" ".join(jieba.lcut(d)) for d in DATA] return [" ".join(get_ngram_seg(d, 1)) for d in DATA]def PRF(y_true, y_pred): acc_test = metrics.accuracy_score(y_true, y_pred) P_test = metrics.precision_score(y_true, y_pred, average='macro') R_test = metrics.recall_score(y_true, y_pred, average='macro') F_test = metrics.f1_score(y_true, y_pred, average='macro') print(acc_test, P_test, R_test, F_test)def CLF(model): x_train, y_train, x_test, y_test = get_train_test() x_train_seg = get_seg(x_train) x_test_seg = get_seg(x_test) vectorizer = CountVectorizer(token_pattern='\\b\\w+\\b') vectorizer.fit(x_train_seg) # print(vectorizer.vocabulary_) # 词汇 bow_train = vectorizer.transform(x_train_seg) # 词袋特征 one-hot向量 bow_test = vectorizer.transform(x_test_seg)# print("特征提取前：", end=' ')# print(bow_train.shape, end=' ')# print(bow_test.shape, end='\t')# tfidf_transformer = TfidfTransformer()# tfidf_transformer.fit(bow_train.toarray())# tfidf_train = tfidf_transformer.transform(bow_train) # TFIDF特征# tfidf_test = tfidf_transformer.transform(bow_test) # FS = SelectKBest(chi2, k=3000) # 选择topK特征 FS = SelectPercentile(chi2, percentile=100) # 选择百分比 bow_train_new = FS.fit_transform(bow_train, np.array(y_train)) feature_index = FS.get_support(True) # 特征选择后，保留的特征维度 bow_test_new = bow_test[:, feature_index]# print("特征提取后：", end=' ')# print(bow_train_new.shape, end=' ')# print(bow_test_new.shape, end='\t') clf = model.fit(bow_train_new.toarray(), np.array(y_train)) y_pred = clf.predict(bow_test_new.toarray()) print(model.__class__.__name__, end='\t') PRF(y_test, y_pred) # print(metrics.classification_report(y_test, y_pred)) 测试不同分类器12345678910111213141516171819202122# CLF(GaussianNB())CLF(MultinomialNB())CLF(LogisticRegression())CLF(SGDClassifier())CLF(DecisionTreeClassifier())CLF(ExtraTreeClassifier())CLF(MLPClassifier())# CLF(BernoulliRBM())CLF(KNeighborsClassifier())# CLF(RadiusNeighborsClassifier())CLF(SVC(C=1, kenerl='linear', gamma=1, shrinkling=True, probability)) # 基于libsvm实现CLF(LinearSVC())# CLF(libsvm)CLF(AdaBoostClassifier())CLF(BaggingClassifier())CLF(ExtraTreesClassifier())CLF(GradientBoostingClassifier())CLF(RandomForestClassifier())# CLF(VotingClassifier())CLF(QDA())CLF(LDA())CLF(XGBClassifier())]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>特征选择</tag>
        <tag>文本分类</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习框架 - 学习链接]]></title>
    <url>%2F2019%2F08%2F12%2Fdeeplearning_framework%2F</url>
    <content type="text"><![CDATA[一、指定 GPU 的 id123456789CUDA_VISIBLE_DEVICES=1 python my_script.pyexport CUDA_VISIBLE_DEVICES=1import osos.environ["CUDA_VISIBLE_DEVICES"] = "0"import torchtorch.cuda.set_device(id) 二、深度学习框架 Neural Networks and Deep Learning：http://neuralnetworksanddeeplearning.com/ 1、TensorFlow 官方API www.tensorflow.org 国内API tensorflow.google.cn TensorFlow从0到1丨开篇：Hello TensorFlow ！ 教学：http://www.tensorflownews.com/ Tensorflow 搭建自己的神经网络 (莫烦 Python 教程) 莫烦 https://github.com/MorvanZhou 主页 TensorFlow 深度学习笔记 TensorFlow实现与优化深度神经网络 2、Keras 英文文档 https://keras.io/ 中文文档 https://keras.io/zh/ 别人翻译 http://keras-cn.readthedocs.io/en/latest/ 莫烦 keras 教程 https://morvanzhou.github.io/tutorials/machine-learning/keras/ 深度学习：Keras入门(一)之基础篇 《Keras 实现 LSTM》笔记 12345678910111213141516171819202122232425keras离线官方文档 https://blog.csdn.net/nima1994/article/details/80579240keras中文文档： https://keras.io/zh/（官方） http://keras-cn.readthedocs.io/en/latest/由于官方文档（更新似乎快点儿）经常访问不了，所以下载查看。1. 下载包 或者 如下命令使用git克隆。git clone https://github.com/keras-team/keras-docs-zh2. 安装mkdocs（pip install mkdocs）后，进入keras-docs-zh文件夹，依次使用如下命令：mkdocs build#生成静态文件mkdocs serve#启动本地服务3. 在浏览器输入进行本地访问：http://localhost:8000使用mkdocs构建的静态网站，可类似食用，并可使用git同步更新http://127.0.0.1:8000## MkDocs 快速入门 https://blog.csdn.net/wirelessqa/article/details/78173401?locationNum=5&amp;fps=1 3、PyTorch 官网：https://pytorch.org/ 英文文档：https://pytorch.org/docs/stable/index.html 中文文档：https://pytorch-cn.readthedocs.io/zh/latest/ PyTorch 中文手册：https://github.com/zergtant/pytorch-handbook 中文官方文档：https://github.com/apachecn/pytorch-doc-zh 神经网络框架-Pytorch使用介绍：https://blog.csdn.net/zzulp/article/details/80573331 安装以前的版本：https://pytorch.org/get-started/previous-versions/#linux-and-windows 4、FastAI 论文网址：http://nlp.fast.ai/category/classification.html Fast.AI 第一课学习笔记 : https://www.jianshu.com/p/df6446057004 Fast.AI课程文件、教学视频及学习环境虚拟机下载分享：https://www.jianshu.com/p/2fe22a6b0ecb 【深度学习】从fast.ai学到的十大技巧：https://blog.csdn.net/ChenVast/article/details/81480865 使用fastai训练的一个性别识别模型：https://www.cnblogs.com/ctsch/p/9498327.html https://github.com/fastai/fastai/tree/master/courses/dl2/imdb_scripts 5、MXNet https://github.com/apache/incubator-mxnet 三、《动手学深度学习》 中文官网：http://zh.gluon.ai/ MxNet版 中文教程：https://github.com/d2l-ai/d2l-zh PyTorch版 中文教程：https://github.com/ShusenTang/Dive-into-DL-PyTorch TF2.0版 中文教程：https://github.com/TrickyGo/Dive-into-DL-TensorFlow2.0]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 基本配置]]></title>
    <url>%2F2019%2F08%2F11%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim 基本配置一、教程 Vim初级：配置和使用 Vim配置（python版） 二、李老师的 vim 配置 主页123456789101112131415161718192021222324252627282930313233343536373839set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码&quot; set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号&quot; set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\ &quot; 设置在状态行显示的信息&quot;set foldenable &quot; 开始折叠&quot;set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为&quot; set foldclose=all &quot; 设置为自动关闭折叠 nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; 用空格键来开关折叠 三、python 注释12345678910111213多行注释： 1. 首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式; 2. 在行首使用上下键选择需要注释的多行; 3. 按下键盘（大写）“I”键，进入插入模式； 4. 然后输入注释符（“//”、“#”等）; 5. 最后按下“Esc”键。注：在按下esc键后，会稍等一会才会出现注释，不要着急~~时间很短的删除多行注释： 1. 首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式; 2. 选定要取消注释的多行; 3. 按下“x”或者“d”.注意：如果是“//”注释，那需要执行两次该操作，如果是“#”注释，一次即可 四、剪切/复制/粘贴 vi/vim复制粘贴命令 1234567891011121314# 一行yy 复制一行dd 剪切一行p（小写） 粘贴（光标往后）P（大写） 粘贴（光标往前）# 多行先将光标移到多行的开始处esc v 进入可视模式再将光标移到多行的结尾处y 复制上面选中的d 剪切选定块到缓冲区p（小写） 粘贴（光标往后）P（大写） 粘贴（光标往前）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP 基本任务]]></title>
    <url>%2F2019%2F08%2F11%2Fnlp_base_task%2F</url>
    <content type="text"><![CDATA[[TOC] NLP基本任务1、词法分析（Lexical Analysis）：对自然语言进行词汇层面的分析，是NLP基础性工作 分词（Word Segmentation/Tokenization）：对没有明显边界的文本进行切分，得到词序列 新词发现（New Words Identification）：找出文本中具有新形势、新意义或是新用法的词 形态分析（Morphological Analysis）：分析单词的形态组成，包括词干（Sterms）、词根（Roots）、词缀（Prefixes and Suffixes）等 词性标注（Part-of-speech Tagging）：确定文本中每个词的词性。词性包括动词（Verb）、名词（Noun）、代词（pronoun）等 拼写校正（Spelling Correction）：找出拼写错误的词并进行纠正 2、句子分析（Sentence Analysis）：对自然语言进行句子层面的分析，包括句法分析和其他句子级别的分析任务 组块分析（Chunking）：标出句子中的短语块，例如名词短语（NP），动词短语（VP）等 超级标签标注（Super Tagging）：给每个句子中的每个词标注上超级标签，超级标签是句法树中与该词相关的树形结构 成分句法分析（Constituency Parsing）：分析句子的成分，给出一棵树由终结符和非终结符构成的句法树 依存句法分析（Dependency Parsing）：分析句子中词与词之间的依存关系，给一棵由词语依存关系构成的依存句法树 语言模型（Language Modeling）：对给定的一个句子进行打分，该分数代表句子合理性（流畅度）的程度 语种识别（Language Identification）：给定一段文本，确定该文本属于哪个语种句子边界检测（Sentence Boundary Detection）：给没有明显句子边界的文本加边界 3、语义分析（Semantic Analysis）：对给定文本进行分析和理解，形成能勾够表达语义的形式化表示或分布式表示 词义消歧（Word Sense Disambiguation）：对有歧义的词，确定其准确的词义 语义角色标注（Semantic Role Labeling）：标注句子中的语义角色类标，语义角色，语义角色包括施事、受事、影响等 抽象语义表示分析（Abstract Meaning Representation Parsing）：AMR是一种抽象语义表示形式，AMR parser把句子解析成AMR结构 一阶谓词逻辑演算（First Order Predicate Calculus）：使用一阶谓词逻辑系统表达语义 框架语义分析（Frame Semantic Parsing）：根据框架语义学的观点，对句子进行语义分析 词汇/句子/段落的向量化表示（Word/Sentence/Paragraph Vector）：研究词汇、句子、段落的向量化方法，向量的性质和应用 4、信息抽取（Information Extraction）：从无结构文本中抽取结构化的信息 命名实体识别（Named Entity Recognition）：从文本中识别出命名实体，实体一般包括人名、地名、机构名、时间、日期、货币、百分比等 实体消歧（Entity Disambiguation）：确定实体指代的现实世界中的对象 术语抽取（Terminology/Giossary Extraction）：从文本中确定术语 共指消解（Coreference Resolution）：确定不同实体的等价描述，包括代词消解和名词消解 关系抽取（Relationship Extraction）：确定文本中两个实体之间的关系类型 事件抽取（Event Extraction）：从无结构的文本中抽取结构化事件 情感分析（Sentiment Analysis）：对文本的主观性情绪进行提取 意图识别（Intent Detection）：对话系统中的一个重要模块，对用户给定的对话内容进行分析，识别用户意图 槽位填充（Slot Filling）：对话系统中的一个重要模块，从对话内容中分析出于用户意图相关的有效信息 5、顶层任务（High-level Tasks）：直接面向普通用户，提供自然语言处理产品服务的系统级任务，会用到多个层面的自然语言处理技术 机器翻译（Machine Translation）：通过计算机自动化的把一种语言翻译成另外一种语言 文本摘要（Text summarization/Simplication）：对较长文本进行内容梗概的提取 问答系统（Question-Answering Systerm）：针对用户提出的问题，系统给出相应的答案 对话系统（Dialogue Systerm）：能够与用户进行聊天对话，从对话中捕获用户的意图，并分析执行 阅读理解（Reading Comprehension）：机器阅读完一篇文章后，给定一些文章相关问题，机器能够回答 自动文章分级（Automatic Essay Grading）：给定一篇文章，对文章的质量进行打分或分级]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解压缩命令-使用教程]]></title>
    <url>%2F2019%2F08%2F11%2Fcompress_commit%2F</url>
    <content type="text"><![CDATA[解压缩命令 后缀：.zip, .tar, .gz, .bz2, .tar.gz, .tar.bz2, .rar Linux下文件的打包、解压缩指令——tar，gzip，bzip2，unzip，rar zip / unzip12解压：unzip filename.zip -d ./ # 默认解压到当前目录，压缩：zip -r filename.zip dirname tar123456789-j：使用bzip2进行解压缩，一般使用.tar.bz2后缀-z：使用gzip进行解压缩，一般使用.tar.gz后缀-c：压缩，建立新的备份文件-x：解压，从备份文件中还原文件-v：显示指令执行过程-f：指定备份文件解包：tar zxvf filename.tar打包：tar zcvf filename.tar dirname gzip / gunzip123456解压1：gunzip filename.gz # 不保留原文件解压1：gunzip –c filename.gz &gt; filename # 保留原文件解压2：gzip -d filename.gz压缩1：gzip filename / gzip -r dirname # 不保留原文件压缩2：gzip –c filename &gt; filename.gz # 保留原文件 bzip2 / bunzip2123456解压1：bzip2 -d filename.bz2 # 不保留原文件解压1：bzip2 -d -k filename.bz2 # 保留原文件解压2：bunzip2 filename.bz2压缩：bzip2 filename # -k 保留原文件压缩：bzip2 -z filename # 强制压缩 rar123压缩：rar a -r experiment.rar ~/experiment/解压：rar x experment.rar ~/test/ # 将文件 experiment.rar 文件解压至指定的文件夹解压：unrar x experment.rar ~/test/ Python读取压缩文件123456789import gzipfr = gzip.open(&apos;xxx.gz&apos;, &apos;r&apos;)line = fr.readline().decode(&apos;utf8&apos;)import bz2fr = bz2.BZ2File(&apos;xxx.bz2&apos;, &apos;r&apos;)import zipfilefr = zipfile.ZipFile(&quot;xxx.zip&quot;, &quot;r&quot;)]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 安装配置教程（Windows、Linux）]]></title>
    <url>%2F2019%2F08%2F10%2Fmysql%2F</url>
    <content type="text"><![CDATA[[TOC] MySQL 配置安装教程 MySQL Community Server 8.0.17 下载链接 一、博客教程1、Windows 系统安装 Win10安装mysql-8.0.11-winx64详细步骤 win10下安装MySQL8小结 windows10+mysql8.0.11zip安装 2、Linux 系统安装 在线安装：ubuntu 安装Mysql 8.0 下载deb包：https://dev.mysql.com/downloads/repo/apt/ 离线安装：ubuntu mysql8.0安装配置过程linux-generic(linux通用版本)、如何在Ubuntu Linux上安装 MySQL 8.0.11、Linux 离线安装mysql8.0 3、MySQL 连接和常用命令 Python3 MySQL 数据库连接 - PyMySQL 驱动 MySQL 教程 二、详细操作① Windows 1、mysql-8.0.17-winx64.zip 文件解压到D盘根目录，新建配置文件 my.ini，新建数据存储目录 Data/ 1234567891011121314151617181920212223242526272829## my.ini 文件内容[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\mysql-8.0.16-winx64# 设置mysql数据库的数据的存放目录datadir=D:\mysql-8.0.16-winx64\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password#开启查询缓存explicit_defaults_for_timestamp=true#skip-grant-tables[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4# 随机初始密码：xxxxxxxxxxxxxx 2、配置系统环境变量：D:\mysql-8.0.16-winx64\bin 3、数据库初始化 1234mysqld --initialize --console # 会默认生成一个随机初始密码，临时保存一下mysqld --install # 安装net start mysql # 启动服务net stop mysql # 停止服务（不执行） 4、打开数据库 cmd 进入 1234567891011121314mysql -u root -p # 输入保存的初始密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'; # 修改数据库密码# 常用命令查看数据库信息：create database 库名;show databases;use 库名;show tables;desc 表名； 显示表的信息show variables like 'character%'; 显示编码select * from 表名;select count(*) from 表名;drop table 表名; # 删表 5、Python 访问数据库 123456789import pymysqlread_con = pymysql.connect(host="localhost", user='root', password='mysql', database='ccks2019', charset='utf8mb4')cur = read_con.cursor()sql = "show tables;" ## sql 命令cur.execute(sql)data = cur.fetchall() ## 获取执行的所有结果print(data)read_con.close()cur.close() 6、建立访客用户 教程 123create user 'guest'@'%' identified by '123456'; # 用户名guest，密码123456，%表示任意主机ipGRANT SELECT ON ccks2019.* TO 'guest'@'%'; # 授权只可以使用 select 权限mysql -uguest -p123456 -h[远程IP地址] -P3306 -Dccks2019 # 访问远程的 MySQL 数据库 ② Ubuntu 1、离线安装 12345678910111213141516tar -xvf mysql-8.0.12-linux-glibc2.12-x86_64.tar.xzmv mysql-8.0.12-linux-glibc2.12-x86_64/ mysqlmv mysql/ /usr/local/mysqlgroupadd mysqluseradd -r -g mysql -s /bin/false mysqlcd /usr/localcd mysqlmkdir mysql-filessudo chown mysql:mysql mysql-filessudo chmod 750 mysql-filesbin/mysqld --initialize --user=mysql# 如果报错，安装apt-cache search libaio apt-get install libaio1./support-files/mysql.server start 2、环境变量 123vim /etc/profileexport PATH="$PATH:/usr/local/mysql/bin"source /etc/profile 3、其他命令同 Windows 系统 step4]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文知识图谱问答 CCKS2019 CKBQA - 参赛总结]]></title>
    <url>%2F2019%2F08%2F04%2Fccks2019_ckbqa%2F</url>
    <content type="text"><![CDATA[[TOC] 调研时间：2019.06.05~2019.06.19 参赛时间：2019.06.28~2019.07.25 中文知识图谱问答（从0到0.6+） Chinese Knowledge Base Question Answering（CKBQA） 一、任务1、任务定义什么是知识库？ 一条条知识，而把大量的知识汇聚起来就成了知识库。 123ex1：奥巴马出生在火奴鲁鲁ex2：姚明是中国人ex3：谢霆锋的爸爸是谢贤 知识来源：维基百科、百度百科等百科全书 特点：非结构化的自然语言、不适合计算机去处理 三元组（triple）（为了方便计算机的处理和理解，需要更加形式化、简洁化的方式去表示知识） 1234- ex1：奥巴马出生在火奴鲁鲁 --&gt; (奥巴马，出生地，火奴鲁鲁)- （主语，谓语，宾语）subject predicate object- （实体，属性，属性值）entity attribute value- （头实体，关系，尾实体）head_entity relation tail_entity 进一步，把实体看作是结点，把关系看作是一条边，包含大量三元组的知识库就构成了一个庞大的知识图谱 什么是知识库问答？ 基于知识库问答（knowledge base question answering, KBQA） 即，给定自然语言问题，通过对问题进行语义理解和解析，进而利用知识库进行查询、推理得出答案。 按应用领域划分：开放领域（百科知识问答等）和特定领域（金融、医疗、宗教、客服等） 评价指标：召回率、精确率、F1值、MRR（平均倒数排序） Q\text{为问题集合，}A_i\text{为对第i个问题给出的答案集合，}G_i\text{为第i个问题的标准答案集合} Macro Precision = \frac{1}{|Q|} \sum_{i=1}^{|Q|}P_i，P_i = \frac {|A_i \cap G_i|} {|A_i|} Macro Recall = \frac{1}{|Q|} \sum_{i=1}^{|Q|}R_i，R_i = \frac {|A_i \cap G_i|} {|G_i|} Averaged F1 = \frac{1}{|Q|} \sum_{i=1}^{|Q|} \frac{2P_iR_i}{P_i+R_i} 两大关键技术 【实体链指】：将问句中的实体名字链接到知识库中特定的实体上，涉及到实体识别和实体消歧。 【关系抽取】：将问句中的实体关系抽取出来，涉及到词性标注、词法句法分析、关系分类等。 举个栗子：姚明的老婆是什么星座？ （姚明，妻子，叶莉）—&gt;（叶莉，星座，天蝎） CCKS2019CKBQA定义 基于中文知识图谱的自然语言问答，简称 CKBQA（Chinese Knowledge Base Question Answering） 即输入一句中文问题，问答系统从给定知识库中选择若干实体或属性值作为该问题的答案。 问题均为客观事实型，不包含主观因素。 理解并回答问题的过程中可能需要进行实体识别、关系抽取、语义解析等子任务。 这些子任务的训练可以使用额外的资源，但是最终的答案必须来自给定的知识库。 2、相关评测简单问题：NLPCC 2015-2018 （对应单元组查询） NLPCC2015 评测：Open Domain Question Answering NLPCC2016 评测：Open Domain Chinese Question Answering NLPCC2017 评测：Open Domain Question Answering NLPCC2018 评测：Open Domain Question Answering 复杂问题：CCKS 2018-2019 （对应多元组查询） CCKS2018 评测 任务四：开放领域的中文问答任务，CCKS2018 COQA 比赛平台 CCKS2019 评测 任务六：中文知识图谱问答，CCKS2019 CKBQA 比赛平台，PKU BASE的在线查询终端：gStore，SPARQL语法规则 3、相关数据训练集NLPCC 2016（14609条）2016、2018测试集答案123456&lt;question id=1&gt; 《机械设计基础》这本书的作者是谁？&lt;answer id=1&gt; 杨可桢，程光蕴，李仲生==================================================&lt;question id=2&gt; 《高等数学》是哪个出版社出版的？&lt;answer id=2&gt; 武汉大学出版社================================================== CCKS 2019 （2298条）1234567q1:莫妮卡·贝鲁奇的代表作？select ?x where &#123; &lt;莫妮卡·贝鲁奇&gt; &lt;代表作品&gt; ?x. &#125;&lt;西西里的美丽传说&gt;q2:《湖上草》是谁的诗？select ?x where &#123; ?x &lt;主要作品&gt; &lt;湖上草&gt;. &#125;&lt;柳如是_（明末&quot;秦淮八艳&quot;之一）&gt; 知识库NLPCC 2016 知识库网盘 三元组（43063796条） 12345空气干燥 ||| 别名 ||| 空气干燥空气干燥 ||| 中文名 ||| 空气干燥空气干燥 ||| 外文名 ||| air drying空气干燥 ||| 形式 ||| 两个空气干燥 ||| 作用 ||| 将空气中的水份去除 提及-实体（7623034条） 12345空气 干燥 ||| 空气干燥air drying ||| 空气干燥 氧化结膜干燥罗育德 ||| 罗育德鳞 ||| 鳞 公子鳞squama ||| 鳞 鳞片 CCKS 2019 知识库网盘，密码：hcu8 开放领域问答的数据+金融领域问答数据 (1/4) 三元组（41009142条）：由&lt;&gt;括起的为实体，由””括起的为文本值 12345&lt;美国奥可斯（香港）国际控股集团&gt; &lt;公司名称&gt; &quot;美国奥可斯（香港）国际控股集团有限公司&quot; .&lt;美国奥可斯（香港）国际控股集团&gt; &lt;成立时间&gt; &quot;2007-06-28&quot; .&lt;美国奥可斯（香港）国际控股集团&gt; &lt;经营范围&gt; &lt;培训&gt; .&lt;美国奥可斯（香港）国际控股集团&gt; &lt;经营范围&gt; &lt;影视&gt; .&lt;美国奥可斯（香港）国际控股集团&gt; &lt;公司口号&gt; &quot;品牌立业，质量最好&quot; . 提及 + 实体 + order（13930118条）：可以用来辅助选手进行实体链接 12345献陵 献陵_（唐高祖李渊陵墓） 1献陵 明献陵 2献陵 献陵_（朝鲜太宗献陵） 3佛罗伦萨 佛罗伦萨_（意大利托斯卡纳大区首府） 1佛罗伦萨 佛罗伦萨足球俱乐部 2 实体 + 类型 + 值（25182628条）：可以用于检查问题类型和答案类型 12345&lt;美国奥可斯（香港）国际控股集团&gt; &lt;类型&gt; &lt;文学作品&gt; .&lt;美国奥可斯（香港）国际控股集团&gt; &lt;类型&gt; &lt;文化&gt; .&lt;寻美中国&gt; &lt;类型&gt; &lt;品牌&gt; .&lt;青春是我和你一杯酒的深&gt; &lt;类型&gt; &lt;文学作品&gt; .&lt;青春是我和你一杯酒的深&gt; &lt;类型&gt; &lt;网络小说&gt; . 4、相关工作 NLPCC2015 第1名评测论文 [1] NLPCC2016 第1-4名评测论文 [2-5] NLPCC2017 第1-2名评测论文 + 会议论文 [6-8] NLPCC2018 第1名评测论文 [9] CCKS2018 第1-3名评测论文 [10-12] CCKS2019 第1-4名评测论文 [13-16] 二、方法1、创建数据库 图数据库：NEO4J、JENA、gStore（Linux） 关系数据库：MySQL（ours）、PostgreSQL 注意：12345678统计字段长度检查数据正误设置主键：id 自增创建索引设置编码：utf8mb4设置引擎：Innodb建立访客用户Python - pymysql 2、创建训练数据分类单多跳问句（二分类） 单跳：SPARQL 只出现一个三元组 123q1:莫妮卡·贝鲁奇的代表作？select ?x where &#123; &lt;莫妮卡·贝鲁奇&gt; &lt;代表作品&gt; ?x. &#125;&lt;西西里的美丽传说&gt; 双跳：SPARQL 出现两个以上三元组 123q616:红豆的演唱者出生在？select ?y where &#123; ?x &lt;代表作品&gt; &lt;红豆_（王菲演唱歌曲）&gt;. ?x &lt;出生地&gt; ?y. &#125;&lt;东城区_（北京市东城区）&gt; 分类链式问句（二分类） 链式：SPARQL 多个三元组呈递进关系，x-&gt;y-&gt;z，非交集关系1234567q894:纳兰性德的父亲担任过什么官职？select ?y where &#123; &lt;纳兰性德&gt; &lt;父亲&gt; ?x. ?x &lt;主要职位&gt; ?y. &#125;&quot;武英殿大学士&quot; &quot;太子太傅&quot;q554:宗馥莉任董事长的公司的公司口号是？select ?y where &#123; ?x &lt;董事长&gt; &lt;宗馥莉&gt;. ?x &lt;公司口号&gt; ?y. &#125;&quot;win happy health,娃哈哈就在你身边&quot; 主谓宾分类（三分类） 问句的答案对应三元组里面的主语，spo=0 123q70:《悼李夫人赋》是谁的作品？select ?x where &#123; ?x &lt;代表作品&gt; &lt;悼李夫人赋&gt;. &#125;&lt;汉武帝_（汉朝皇帝）&gt; 问句的答案对应三元组里面的谓语，spo=1 123q506:林徽因和梁思成是什么关系？select ?x where &#123; &lt;林徽因_（中国建筑师、诗人、作家）&gt; ?x &lt;梁思成&gt;. &#125;&lt;丈夫&gt; 问句的答案对应三元组里面的宾语，spo=2 123q458:天津大学的现任校长是谁？select ?x where &#123; &lt;天津大学&gt; &lt;现任校长&gt; ?x . &#125;&lt;李家俊_（天津市委委员，天津大学校长）&gt; 实体提及识别（NER序列标注） 根据训练语料的SPARQL语句，查找实体的提及，反向构建训练数据123456789101112131415161718q1408:电影《怦然心动》的主要演员？select ?x where &#123; &lt;怦然心动_（美国2010年罗伯·莱纳执导电影）&gt; &lt;主演&gt; ?x. &#125;&lt;艾丹·奎因&gt; &lt;玛德琳·卡罗尔&gt; &lt;卡兰·麦克奥利菲&gt; &lt;约翰·玛哈尼&gt; &lt;摩根·莉莉&gt;电 O影 O《 O怦 B-LOC然 I-LOC心 I-LOC动 I-LOC》 O的 O主 O要 O演 O员 O？ O 关系抽取（语义相似度计算，二分类） 查找实体的关系中与问句最相近的关系 一个正例，再从对应实体的关系中随机抽取5个作为负例12345678910q267:里奥·梅西的生日是什么时候？select ?x where &#123; &lt;里奥·梅西_（阿根廷足球运动员）&gt; &lt;出生日期&gt; ?x . &#125;&quot;1987-06-24&quot;里奥·梅西的生日是什么时候？ 出生日期 1里奥·梅西的生日是什么时候？ 妻子 0里奥·梅西的生日是什么时候？ 所属运动队 0里奥·梅西的生日是什么时候？ 中文名 0里奥·梅西的生日是什么时候？ 类型 0里奥·梅西的生日是什么时候？ 外文名 0 实体链接（二分类） 查找问句中实体提及对应的唯一实体 6个特征：order、提及初始分、问题和提及字符匹配度、问题和实体语义相似度、问题和实体字符匹配度、问题和实体关系的最大相似度 —&gt; 标签1234567q2035:张三丰创立了什么门派？select ?x where &#123; &lt;张三丰_（武侠小说人物）&gt; &lt;荣誉&gt; ?x . &#125;&quot;创立武当派&quot;张三丰创立了什么门派？ &lt;张三丰_（南宋至明初道士）&gt; 1.0 1.0 0.43 0.15978466 0.6 0.99257445 0张三丰创立了什么门派？ &lt;张三丰_（武侠小说人物）&gt; 0.9 1.0 0.43 0.97132427 0.58 0.99660385 1张三丰创立了什么门派？ &lt;张三丰_（桌游《英雄杀》中的英雄之一）&gt; 0.8 1.0 0.43 0.920861 0.38 0.0007164952 0 纠正错误标注 由于时间问题只纠正了一部分 实体中含多余空格：q10、q149、q490、q559、q723、q1191 多个三元组未以’.’分割：q65 实体标注错误：q124、q300、q422、q432、q449、q1699 关系标注错误：q3811234567891011q10:北京奥运会的口号是什么？select ?x where &#123; &lt;2008年北京奥运会 &gt; &lt;口号&gt; ?x. &#125; &quot;同一个世界，同一个梦想&quot;修正：select ?x where &#123; &lt;2008年北京奥运会&gt; &lt;口号&gt; ?x. &#125;q124:吉野家创建于什么时候？select ?x where &#123; &lt;吉野家&gt; &lt;创始时间&gt; ?x. &#125;&quot;1899&quot;修正：select ?x where &#123; &lt;吉野家_（日本牛肉饭店）&gt; &lt;创始时间&gt; ?x. &#125; 3、训练模型 分类单多跳问句（二分类：BERT 做单句子分类）acc=89.13% 123456789101112# acc低的原因：以下问题实则单跳可以解决q542:习大大是哪里毕业的？select ?y where &#123; ?x &lt;别名&gt; &quot;习大大&quot; . ?x &lt;毕业院校&gt; ?y . &#125;&quot;清华大学&quot;q1560:小马哥有哪些主要成就？select ?y where &#123; ?x &lt;别名&gt;&quot;小马哥&quot;. ?x &lt;主要成就&gt; ?y. &#125;&quot;改变中国SNS现状&quot; &quot;1998年创立 腾讯公司&quot; &quot;腾讯慈善基金会&quot;q1574:习大大什么时候入党？select ?y where &#123; ?x &lt;别名&gt; &quot;习大大&quot;. ?x &lt;入党时间&gt; ?y . &#125;&quot;1974&quot; 分类链式问句（二分类：BERT 做单句子分类）acc=96.15% 主谓宾分类（三分类：BERT 做单句子分类）acc=91.63% 实体提及识别（NER序列标注：BERT+BiLSTM+CRF 的 NER 模型） 12345评价指标：召回率 Recall只使用单跳数据，初始结果 87.28%改进：去除提及的书名号和双引号，结果 89.47%，但只能识别0~1个实体提及加入单多跳所有数据，模型测试结果 88.24%，可以识别出多个提及 关系抽取（语义相似度计算，二分类：BERT 做句子对分类） 12345单跳数据初始结果83.7%，mask掉实体提及81.06%，最终模型是混合 nlpcc2016 和 ccks2019 的所有数据改进：nlpcc2016数据负例是从关系全集中抽取的，改成ccks2019从对应实体的所有候选关系中抽取 实体链接（二分类：xgboost 做分类） 1234567891011正例结果acc：89.15%，按概率分布评价acc：97.34%改进1：提及得分：order、1/order、提及初始分、实体长度、实体长度占问题长度比实体得分：问题和实体的语义相似度、问题和实体后缀的语义相似度、问题和实体后缀的杰卡德系数关系得分：问题和实体关系的最大相似度，问题和实体关系的最大杰卡德系数正例结果acc：98.90%，按概率分布评价acc：99.13%，初赛最后一天实现，复赛未能派上用场，很遗憾。改进2：查找所有候选实体，提及左右进行扩展或删减，外加百度百科搜索实体链接后还是没找到实体，采用暴力搜索，逐个字符匹配若识别出多个提及，则实体链接也对应多个，但链式问题搜索答案时只使用得分最高的 4、预测数据 实体提及识别要考虑问句中出现的空格问题123&#123;&quot;id&quot;: &quot;q1&quot;, &quot;question&quot;: &quot;\&quot;成败一知己，生死两妇人\&quot;所说的人物有什么重大成就？&quot;, &quot;hop&quot;: &quot;1&quot;, &quot;spo&quot;: &quot;2&quot;, &quot;chain&quot;: &quot;1&quot;, &quot;mention_list&quot;: [&quot;成败一知己，生死两妇人&quot;]&#125;&#123;&quot;id&quot;: &quot;q2&quot;, &quot;question&quot;: &quot;葬于茂陵的皇帝在位于哪段时间？&quot;, &quot;hop&quot;: &quot;1&quot;, &quot;spo&quot;: &quot;0&quot;, &quot;chain&quot;: &quot;1&quot;, &quot;mention_list&quot;: [&quot;茂陵&quot;, &quot;皇帝&quot;]&#125;&#123;&quot;id&quot;: &quot;q3&quot;, &quot;question&quot;: &quot;\&quot;光武中兴\&quot;说的是哪位皇帝？&quot;, &quot;hop&quot;: &quot;0&quot;, &quot;spo&quot;: &quot;0&quot;, &quot;chain&quot;: &quot;0&quot;, &quot;mention_list&quot;: [&quot;光武中兴&quot;]&#125; 5、搜索答案 注释 123456hop=0 表示是单跳问题（如：姚明的女儿是谁？），hop=1 表示是多跳问题（单跳问题仅需一个三元组，多跳需两个以上）spo=0 表示已知谓宾求主语，spo=1 表示已知主宾求谓语，spo=2表示已知主谓求宾语（如：姚明的女儿是谁？）chain=0 表示非链式问题，chain= 表示链式问题（如：姚明的女儿的年龄是多少？）ner 表示用NER模型识别出问句中的实体提及（如：姚明的女儿是谁？ 提及：姚明）Entity Linking 表示实体链指，找出提及对应的实体（如：姚明的女儿是谁？ 实体：&lt;姚明_（中职联公司董事长兼总经理）&gt;）Relation Extraction 表示关系抽取，找出问题中关系（如：姚明的女儿是谁？ 关系：&lt;女儿&gt;） 详细介绍 12345step1：先对问题进行分类（判断是否单多跳、是否主谓宾、是否链式）和提及识别；step2：根据识别到的提及，进行左右扩展或删减，搜索所有的候选实体，根据一组特征对候选实体打分排序（实体链接模型），取top1；step3：根据spo值，搜索实体对应的所有关系，与当前问题计算语义相似度（关系抽取模型），取top1，搜索数据库得到统一单跳问题的求解；step4：如果是链式且是多跳问题，将step3得到的答案作为实体再进行一遍step3，得到多跳链式问题的求解；step5：如果是非链式且识别到多个实体，对每个实体搜索数据库，查询对应的所有候选三元组，然后求交集，得到多跳多实体问题的求解。 三、总结 参加完CCKS2019评测会议后再补充 。。。。。。 本方法暂时没有开源的打算… … 四、参考文献 [1] NLPCC2015 1st Ye Z, Jia Z, Yang Y, et al. Research on open domain question answering system[M]//Natural Language Processing and Chinese Computing. Springer, Cham, 2015: 527-540. [2] NLPCC2016 1st Lai Y, Lin Y, Chen J, et al. Open domain question answering system based on knowledge base[M]//Natural Language Understanding and Intelligent Applications. Springer, Cham, 2016: 722-733. [3] NLPCC2016 2nd Yang F, Gan L, Li A, et al. Combining deep learning with information retrieval for question answering[M]//Natural Language Understanding and Intelligent Applications. Springer, Cham, 2016: 917-925. [4] NLPCC2016 3rd Xie Z, Zeng Z, Zhou G, et al. Knowledge base question answering based on deep learning models[M]//Natural Language Understanding and Intelligent Applications. Springer, Cham, 2016: 300-311. [5] NLPCC2016 4th Wang L, Zhang Y, Liu T. A deep learning approach for question answering over knowledge base[M]//Natural Language Understanding and Intelligent Applications. Springer, Cham, 2016: 885-892. [6] NLPCC2017 1st Lai Y, Jia Y, Lin Y, et al. A Chinese question answering system for single-relation factoid questions[C]//National CCF Conference on Natural Language Processing and Chinese Computing. Springer, Cham, 2017: 124-135. [7] NLPCC2017 2nd Zhang H, Zhu M, Wang H. A Retrieval-Based Matching Approach to Open Domain Knowledge-Based Question Answering[C]//National CCF Conference on Natural Language Processing and Chinese Computing. Springer, Cham, 2017: 701-711. [8] NLPCC2017 会议 周博通, 孙承杰, 林磊, et al. 基于LSTM的大规模知识库自动问答[J]. 北京大学学报：自然科学版, 2018. [9] NLPCC2018 1st Ni H, Lin L, Xu G. A Relateness-Based Ranking Method for Knowledge-Based Question Answering[C]//CCF International Conference on Natural Language Processing and Chinese Computing. Springer, Cham, 2018: 393-400. [10] CCKS2018 1st A QA Search Algorithm based on the Fusion Integration of Text Similarity and Graph Computation [11] CCKS2018 2nd A Joint Model of Entity Linking and Predicate Recognition for Knowledge Base Question Answering [12] CCKS2018 3rd Semantic Parsing for Multiple-relation Chinese Question Answering [13] CCKS2019 1st 混合语义相似度的中文知识图谱问答系统 [14] CCKS2019 2nd Combining Neural Network Models with Rules for Chinese Knowledge Base Question Answering [15] CCKS2019 3rd Multi-Module System for Open Domain Chinese Question Answering over Knowledge Base [16] CCKS2019 4th DUTIR中文开放域知识库问答评测报告 五、相关博客 基于知识图谱的问答系统入门之—NLPCC2016KBQA数据集 【代码未公开】发布于 2019-01-02，编辑于 2019-05-29 问答QA（二）基于BERT的知识库问答实战，Github：bert-kbqa-NLPCC2017 2019年03月09日 00:12:35 基于BERT的KBQA探索-知乎，基于BERT的KBQA探索-CSDN，Github：KBQA-BERT 代码有点像上面的 发布于 2019-04-19，编辑于 2019-07-03 NLPCC2016 KBQA 1st 方案 CCKS2018 CKBQA 1st 方案 自由讨论 | KBQA从入门到放弃—入门篇 KBQA从入门到放弃 - Part 2 | 每周话题精选 #09 KBQA 知识库问答领域研究综述（未完待续。。） 基于知识库的问答：seq2seq模型实践 KBQA 个人总结 揭开知识库问答KB-QA的面纱0·导读篇 知识图谱问答总结 肖仰华 | 基于知识图谱的问答系统 基于知识图谱的问答系统(KBQA) 各类QA问答系统的总结与技术实现（持续更新） 知识图谱入门 (九)知识问答 KBQA: 基于开放域知识库上的QA系统 | 每周一起读]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>NER</tag>
        <tag>数据库</tag>
        <tag>文本分类</tag>
        <tag>KBQA</tag>
        <tag>BERT</tag>
        <tag>知识图谱</tag>
        <tag>SPARQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的排序算法]]></title>
    <url>%2F2019%2F04%2F17%2Fsort%2F</url>
    <content type="text"><![CDATA[一、复杂度 排序方式 平均T(n) 最坏T(n) 最好T(n) 空间复杂度 稳定性 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 希尔排序 O(n^1.3) O(n^2) O(n) O(1) 不稳定 快速排序 O(nlogn) O(n^2) O(nlogn) O(logn) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+rd) 稳定 二、代码实现1、直接插入排序 insert12345678# 将 L[i] 插入到已经有序的子序列 L[1 2 ... i-1] 中def InsertSort(arr): for i in range(1, len(arr)): j = i while j &gt; 0 and arr[j] &lt; arr[j-1]: arr[j], arr[j-1] = arr[j-1], arr[j] j -= 1 2、冒泡排序 bubble1234567# 对相邻的元素两两进行比较，顺序相反则进行交换，这样每一趟最大的元素浮到顶端def BubbleSort(arr): for i in range(len(arr)-1): for j in range(len(arr)-1-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] 3、简单选择排序 select1234567891011# 第i趟排序从 L[i,i+1,...,n] 中选择关键字最小的元素与 L[i] 比较# 每一趟从待排序的数据元素中选择最小的元素作为首元素def SelectSort(arr): for i in range(len(arr)-1): minv = i for j in range(i+1, len(arr)): if arr[j] &lt; arr[minv]: minv = j if minv != i: arr[minv], arr[i] = arr[i], arr[minv] 4、希尔排序 shell（跳着插入排序）123456789101112距离为 di 的记录放在同一个组中，进行直接插入排序di = 4, 2, 1def ShellSort(arr): step = len(arr) / 2 while step &gt; 0: for i in range(step, len(arr)): # 插入排序 j = i while j &gt;= step and arr[j] &lt; arr[j-step]: arr[j], arr[j-step] = arr[j-step], arr[j] j -= step step = step / 2 5、快速排序 quick123456789101112131415161718192021222324252627282930待排序表 L[1,2,...,n] 中任取一个元素 pivot 作为基准或枢纽，将表划分成两部分，一部分小于 pivot，一部分大于或等于 pivotL[1,2,...,k-1] 和 L[k+1,...,n] , L[k] = pivot操作：以当前表中第一个元素作为枢纽，对表进行划分将表中比枢纽值大的元素向右移动，小的向左移动移动采用从两端往中间夹入的方式（可用于求n个元素中第k小的元素）def Partition(arr, begin, end): # 划分元素 pivot = arr[begin] # 选取第一个元素作为基准 left = begin + 1 right = end while True: while left &lt;= right and arr[left] &lt;= pivot: left += 1 while left &lt;= right and arr[right] &gt;= pivot: right -= 1 if left &lt; right: arr[left], arr[right] = arr[right], arr[left] else: break arr[begin], arr[right] = arr[right], pivot # 划分元素放到中间位置 return right # 返回划分元素的下标def QuickSort(arr, begin, end): if begin &lt; end: k = Partition(arr, begin, end) Partition(arr, begin, k-1) Partition(arr, k+1, end) 6、堆排序 heap sort12345678910111213141516171819202122232425大顶堆（完全二叉树）：子节点小于父节点建堆 A[0,2,...,n-1]，移除根节点，将A[0]与A[n-1]交换，做最大堆调整的递归运算，建堆 A[0,2,...,n-2]，将A[0]与A[n-2]交换，直到 A[0]与A[1]交换思想可用于求大量元素中最小的或最大的几个元素def MaxHeap_adjust(arr, low, high): tmp = arr[low] # 父节点 while 2 * low + 1 &lt;= high: child = 2 * low + 1 # 左子节点 if child &lt; high and arr[child] &lt; arr[child+1]: child += 1 if arr[child] &lt; tmp: break arr[low] = arr[child] low = child arr[low] = tmpdef MaxHeapSort(arr): n = len(arr) for i in range(n/2-1, -1, -1): # 从下往上调 MaxHeap_adjust(arr, i, n-1) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # 最大值放最后面 MaxHeap_adjust(arr, 0, i-1) # 重新调整一下 7、二路归并排序 merge（分治）12345678910111213141516171819202122n 个记录看成是 n 个有序的子表，两两归并，得到 n/2 个有序表，再归并def Merge(left, right): i, j = 0, 0 res = [] # 缺点：需要辅助空间 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 res += left[i:] if i &lt; len(left) else right[j:] return resdef MergeSort(arr): if len(arr) &lt;= 1: return arr middle = len(arr) / 2 left = MergeSort(arr[:middle]) right = MergeSort(arr[middle:]) return Merge(left, right) 8、基数排序 radix（桶排序）12对数字最高位优先和最低位优先进行排序例如：先按个位从小到大，再按十位从小到大，再按百位从小到大]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 cuda、cudnn、nvidia 驱动]]></title>
    <url>%2F2019%2F04%2F17%2Fcuda%2F</url>
    <content type="text"><![CDATA[〇、TensorFlow 与 cuda 的对应版本 官方链接：https://tensorflow.google.cn/install/source123456789101112131415版本 Python 版本 编译器 编译工具 cuDNN CUDAtensorflow_gpu-1.13.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.19.2 7.4 10.0tensorflow_gpu-1.12.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.15.0 7 9tensorflow_gpu-1.11.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.15.0 7 9tensorflow_gpu-1.10.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.15.0 7 9tensorflow_gpu-1.9.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.11.0 7 9tensorflow_gpu-1.8.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.10.0 7 9tensorflow_gpu-1.7.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.9.0 7 9tensorflow_gpu-1.6.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.9.0 7 9tensorflow_gpu-1.5.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.8.0 7 9tensorflow_gpu-1.4.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.5.4 6 8tensorflow_gpu-1.3.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.4.5 6 8tensorflow_gpu-1.2.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.4.5 5.1 8tensorflow_gpu-1.1.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.4.2 5.1 8tensorflow_gpu-1.0.0 2.7、3.3-3.6 GCC 4.8 Bazel 0.4.2 5.1 8 一、查看版本1、查看 cuda 版本 cat /usr/local/cuda/version.txt nvcc -V 2、查看 cudnn 版本 cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 cat /usr/include/cudnn.h | grep CUDNN_MAJOR -A 2 3、查看显卡驱动版本 cat /proc/driver/nvidia/version nvidia-smi 二、安装1、安装cuda Ubuntu16.04+cuda9.0安装教程 下载链接：https://developer.nvidia.com/cuda-toolkit-archive 执行命令：sudo sh cuda_9.0.176_384.81_linux.run ，不要安装驱动 配置系统环境变量：sudo vim /etc/profile 或者用户环境变量：vim ~/.bashrc1234export PATH=/usr/local/cuda-9.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-9.0/lib64$LD_LIBRARY_PATH# 系统环境变量可能要重启电脑 `sudo reboot` 2、安装nvidia驱动 列出所有可用的 NVIDIA 设备信息：nvidia-smi -L 查找适配自己电脑GPU的驱动：http://www.nvidia.cn/Download/index.aspx?lang=cn 解决nvidia升级驱动后版本匹配问题123456789sudo apt-get purge nvidia*sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia-384 nvidia-settingsreboot注：如果要是不行，可能需要在bios里将显卡先设置成CPU集卡验证1.输入nvidia-smi查看2.prime-select query查看当前选用的显卡 3、安装cudnn 下载链接：https://developer.nvidia.com/rdp/cudnn-archive 执行命令拷贝文件，后者用软连接 12345tar -zxvf cudnn-9.0-linux-x64-v7.1.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/include/ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/ -d sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 配置系统环境变量：sudo vim /etc/profile 123export PATH=/usr/local/cuda/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export CUDA_HOME=/usr/local/cuda 刷新环境变量：source /etc/profile 三、卸载卸载 cuda1234cd /usr/local/cuda/binsudo ./uninstall_cuda_8.0.plcd /usr/localsudo rm -rf cuda-8.0 四、相关链接官方教程cuda、cudnn、驱动版本查看及nvidia驱动、cuda安装及卸载ubuntu下卸载cuda8.0，和安装cuda9.0，cudnn7.0,tensorflow-gpu=1.8]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评价准则]]></title>
    <url>%2F2018%2F10%2F07%2Fevaluation%2F</url>
    <content type="text"><![CDATA[谈谈评价指标中的宏平均和微平均 分类器的性能表现评价（混淆矩阵，准确率，召回率，F1,mAP、ROC曲线） python + sklearn ︱分类效果评估——acc、recall、F1、ROC、回归、距离 准确率(Accuracy), 精确率(Precision), 召回率(Recall)和F1-Measure 对于二分类问题，可将样例根据其真实类别和分类器预测类别划分为： 0 1 2 真实类别 预测类别 真正例 True Positive TP 正例 正例 假正例 False Positive FP 负例 正例 假负例 False Negative FN 正例 负例 真负例 True Negative TN 负例 负例 然后可以构建混淆矩阵（Confusion Matrix）如下表所示： - 预测 正例 预测 负例 真实 正例 TP FN 真实 负例 FP TN \text{测试集：} X_{test} = \{(x_i, y_i) | i = 1, 2, ..., N \}N \text{：表示测试集中的样本个数}x_i \text{：表示测试集中的数据样本}y_i \text{：表示数据样本的类别号}\text{假设要研究的分类问题含有 m 个类别，则} y_i \in \{c_1, c_2, ..., c_m \}\text{在分类问题中对于测试集的第j个类别，假设被正确分类的样本数量为} TP_j\text{被错误分类的样本数量为} FN_j\text{其它类别被错误分类为该类的样本数量为} FP_j 精确度Accuracy = \frac {\sum_{j=1}^mTP_j} {N} = \frac {TP+TN} {N}= \frac { \text{分类正确的样本个数} } { \text{分类的所有样本个数} }查全率/召回率 R 第j个类别的查全率表示在本类样本中，被正确分类的样本所占的比例，它表示这个类别的分类精度 Recall_j = \frac {TP_j} {TP_j + FN_j} , 1 \leq j \leq m查准率/准确率 P 第j个类别的查准率表示被分类为该类的样本中，真正属于该类的样本所占的比例，它表示这个类别的分类纯度 Precision_j = \frac {TP_j} {TP_j + FP_j} , 1 \leq j \leq mF1 标准 F1 值比较合理地评价分类器对每一类样本的分类性能。 F_\beta = \frac {(1 + \beta^2) * P * R} {(\beta^2 * P) + R}F1 = \frac {2 * R_j * P_j} {R_j + P_j} , 1 \leq j \leq m, \beta = 1= \frac {2} {1/P + 1/R} 宏平均 Macro-averaging 先对每一个类统计指标值，然后在对所有类求算术平均值 Macro\_P = \frac{1}{n}\sum_{i=1}^mP_iMacro\_R = \frac{1}{n}\sum_{i=1}^mR_iMacro\_F1 = \frac {2 * Macro\_P * Macro\_R} {Macro\_P + Macro\_R}Averaged\_F1 = \frac{1}{n}\sum_{i=1}^mF1_i微平均 Micro-averaging 对数据集中的每一个实例不分类别进行统计建立全局混淆矩阵，然后计算相应指标 Micro\_P = \frac {\sum_{i=1}^mTP_i} {\sum_{i=1}^mTP_i + \sum_{i=1}^mFP_i}= \frac {\sum_{i=1}^mTP_i} {N}Micro\_R = \frac {\sum_{i=1}^mTP_i} {\sum_{i=1}^mTP_i + \sum_{i=1}^mFN_i}= \frac {\sum_{i=1}^mTP_i} {N}Micro\_F1 = \frac {2 * Micro\_P * Micro\_R} {Micro\_P + Micro\_R}\text{如果对所有类别求微平均，那么上面三个值是相等的，且 = accuracy。}\text{如果数据集中各个类的分布不平衡的话，建议使用微平均，宏平均没有考虑到各个类别的样本大小。}]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征选择方法]]></title>
    <url>%2F2018%2F10%2F06%2Ffeature_select%2F</url>
    <content type="text"><![CDATA[CHI、IG： http://songlj.iteye.com/blog/2241763 IG、CHI、TC、TS、IIG 文本挖掘（四）——特征选择 From My Github - 文本分类 表1：词频统计（文档数量）其中，文档总数：N = A+B+C+D - 包含词条 t 不包含词条 t 属于类别 c A C 不属于类别 c B D 1、文档频率 DF （document frequency） 文档频率指训练集中包含该特征词条的文本总数 DF = A + B选择 DF &gt; 某个阈值的特征词条 2、信息增益 IG （information gain） 通过特征词在文本中出现和不出现前后的信息量之差来推断该特征词所带的信息量 IG(t) = H(c) - H(c|t)H(c) = - \sum_{i=1}^mP(c_i)log P(c_i)H(c|t) = - P(t) \sum_{i=1}^m P(c_i|t) log P(c_i|t) - P(\bar{t}) \sum_{i=1}^m P(c_i|\bar{t}) log P(c_i|\bar{t})P(t)=\frac {A+B}{N} \text{：表示样本集中包含词 t 的文本的概率}P(c_i)=\frac {A+C}{N} \text{：表示类文本在样本集中出现的概率}P(c_i|t)=\frac {A}{A+B} \text{：表示文本包含词 t 时属于 c 的条件概率}3、互信息 MI （mutual information） 互信息衡量了特征词条和类别之间的相关性MI(t,c) = log \frac {P(t,c)} {P(t)*P(c)} = log \frac {\frac{A}{N}} {\frac{A+B}{N}*\frac{A+C}{N}}= log \frac {A*N} {(A+C)*(A+B)} = log \frac { \frac{A}{A+C} } { \frac{A+B}{N} }= log \frac{A}{A+C} - log \frac{A+B}{N} = log P(t|c) - log P(t)MI_{avg}(t) = \sum_{i=1}^m P(c_i) MI(t,c_i)MI_{max}(t) = \max_{i=1}^m \{ MI(t,c_i) \} MI(t,c) = 0，当 t 和 c 相互独立时弱点：得分被词条的边缘概率强烈的影响；（条件概率相等时，低频词比高频词有更高的分数） 4、卡方统计 CHI（Chi-Square Statistic） 卡方统计量也用于表征两个变量的相关性，与互信息相比，它同时考虑了特征在某类文本中出现和不出现时的情况 度量了 t 和 c 之间的独立性CHI(t,c) = \frac {N * (AD-BC)^2} {(A+C)*(B+D)*(A+B)*(C+D)}CHI_{avg}(t) = \sum_{i=1}^m P(c_i) CHI(t,c_i)CHI_{max}(t) = \max_{i=1}^m \{ CHI(t,c_i) \} 卡方统计是一个规范值，因此卡方统计值对于相同的类别可以跨词进行比较 如果列联表中的任何单元被轻微填充，这种归一化就会失效（低频词的例子） 因此，卡方统计对于低频词是不可靠的。 5、词条强度/单词权 TS （term strength）法1：博客 TS 计算的是一个词出现的条件概率，即该词在一对相关文本中的某一个文本中出现的条件下，在另一个文本中出现的概率123（1）计算文本数据集中每一对文本的相似度；（2）选择出所有相似度超过阈值的文本对；（3）对所有的单词，根据下式计算它的单词权。 TS(t) = \frac {\text{均包含词t的相关文本对数}} {\text{文本集中的相关文本对总数}}若有一个文本集，其中有N篇文本，M对相关文本有序对，有K对同时包含词t的相关文本有序对，则 TS(t)=P(t|M) = \frac{K}{M} = \frac{\sum_{i=1}^m c_i\text{类包含词t相关文本对数}} {\sum_{i=1}^m c_i\text{类相关文本对数}}\approx \sum_{i=1}^m c_i\text{类包含词t相关文本对数}123即TS(t)表示在文本集的所有相关文本有序对的集合中，同时包含词t的相关文本有序对的比例。若TS(t)值越大，说明词t在相关文本集中出现得越多，即越重要。缺点：要计算文本间的相似度，所以复杂度较高；阈值不易确定。 法2：（Yang Yiming 论文里）文本聚类中的特征选择方法 这个方法基于词条出现在密切相关的文档中的频率来评估词条的重要性 使用一组训练文档来派生出文档对，其相似度（余弦值）高于某个阈值 x 和 y 是一对相似文档 TS(t) = P(t \in y | t \in x) 基于文档聚类，假设有许多共享词的文档是相似的，在相关文档的重叠区域内的词条的信息量相对较大 这个方法不是基于特定任务的；不使用与词条类别相关的信息。 法3：PPT-1 18页 PPT-2 18页 词强度（term strength） \text{已知一个词（特征）在某文档（实例）中出现，}\text{该词在同类（目标函数值相同）文档中出现的概率为词强度。}s(t) = P(t \in d_{Y=y}^i | t \in d_{Y=y}^j)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
        <tag>特征选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StandfordNLP NLTK 中文工具配置教程]]></title>
    <url>%2F2018%2F09%2F10%2FStandfordNLP%20NLTK%2F</url>
    <content type="text"><![CDATA[Python3 NLTK StandfordNLP 中文工具包配置教程 配置教程-1 配置教程-2 1. 必要的安装包 Python3 Anaconda3 NLTK Anaconda3 jdk_1.8 Java SE Development Kit 8 Downloads StanfordNLP NLTK工具包 StanfordNLP 中文处理工具包 百度云链接 密码：o1l3 【本人打包好】 123456# 中文处理工具包 stanford-jar.zip 文件内容: `ls`chinese.misc.distsim.crf.ser.gz stanford-ner-3.9.1.jarchinese-distsim.tagger stanford-parser.jarchinesePCFG.ser.gz stanford-parser-3.9.1-models.jardata/ stanford-postagger-3.9.1.jarslf4j-api-1.7.25.jar stanford-segmenter-3.9.1.jar 2. 调用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import osimport nltk## java 环境java_path = "D:\Program Files\Java\jdk1.8.0_162\\bin\java.exe" # java安装地址os.environ['JAVAHOME'] = java_pathbase_dir = 'D:\data\stanfordnlp\stanford-jar' # StanfordNLP 中文处理工具包的路径## 1. 分词#########################################################################################from nltk.tokenize.stanford_segmenter import StanfordSegmentersegmenter = StanfordSegmenter( path_to_jar=os.path.join(base_dir, 'stanford-segmenter-3.9.1.jar'), path_to_slf4j=os.path.join(base_dir, 'slf4j-api-1.7.25.jar'), path_to_sihan_corpora_dict=os.path.join(base_dir, 'data'), path_to_model=os.path.join(base_dir, 'data/pku.gz'), path_to_dict=os.path.join(base_dir, 'data/dict-chris6.ser.gz'))sent = '这是斯坦福中文分词器测试，南京市长江大桥。我在博客园开了一个博客，我的博客名叫伏草惟存，写了一些自然语言处理的文章。'print(segmenter.segment(sent))## 2. 命名实体识别NER#########################################################################################from nltk.tag import StanfordNERTaggerchi_tagger = StanfordNERTagger( model_filename=os.path.join(base_dir, 'chinese.misc.distsim.crf.ser.gz'), path_to_jar=os.path.join(base_dir, 'stanford-ner-3.9.1.jar') )result = '四川省 成都 信息 工程 大学 我 在 博客 园 开 了 一个 博客 ， 我 的 博客 名叫 伏 草 惟 存 ， 写 了 一些 自然语言 处理 的 文章 。\r\n'for word, tag in chi_tagger.tag(result.split()): print(word,tag)## 3. 词性标注#########################################################################################from nltk.tag import StanfordPOSTaggerchi_tagger = StanfordPOSTagger( model_filename=os.path.join(base_dir, 'chinese-distsim.tagger'), path_to_jar=os.path.join(base_dir, 'stanford-postagger-3.9.1.jar') )result = '四川省 成都 信息 工程 大学 我 在 博客 园 开 了 一个 博客 ， 我 的 博客 名叫 伏 草 惟 存 ， 写 了 一些 自然语言 处理 的 文章 。\r\n'print(chi_tagger.tag(result.split()))## 4. 句法分析#########################################################################################from nltk.parse.stanford import StanfordParserchi_parser = StanfordParser( os.path.join(base_dir, 'stanford-parser.jar'), os.path.join(base_dir, 'stanford-parser-3.9.1-models.jar'), os.path.join(base_dir, 'chinesePCFG.ser.gz') )sent = u'北海 已 成为 中国 对外开放 中 升起 的 一 颗 明星'print(list(chi_parser.parse(sent.split())))## 5. 依存句法分析#########################################################################################from nltk.parse.stanford import StanfordDependencyParserchi_parser = StanfordDependencyParser( os.path.join(base_dir, 'stanford-parser.jar'), os.path.join(base_dir, 'stanford-parser-3.9.1-models.jar'), os.path.join(base_dir, 'chinesePCFG.ser.gz') )res = list(chi_parser.parse('四川 已 成为 中国 西部 对外开放 中 升起 的 一 颗 明星'.split()))for row in res[0].triples(): print(row)]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>分词</tag>
        <tag>NER</tag>
        <tag>词性标注</tag>
        <tag>句法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单使用 Git]]></title>
    <url>%2F2018%2F09%2F10%2Fgit%2F</url>
    <content type="text"><![CDATA[[TOC] Git简明指南：（可能需要翻墙）git - 简明指南 码云（Gitee.com）帮助文档 官网：https://git-scm.com/ 入门教程：https://git-scm.com/book/zh/v2 廖雪峰Git教程 菜鸟教程：https://www.runoob.com/git/git-tutorial.html 易百教程：https://www.yiibai.com/git 远程仓库：github, gitlab, gitee 一、入门1、简单配置1、初始配置 12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的邮箱地址&quot; 2、查看配置信息：git config --list 3、添加：git add .，删除：git rm &lt;filename&gt; 4、删除和提交：git commit -m &quot;这一步操作的名字&quot; 5、推送到远端：git push origin master 6、远程服务器：git remote add origin &lt;仓库&gt; 123$ git remote add &lt;name&gt; &lt;url&gt; # 添加一个仓库$ git remote remove &lt;name&gt; # 删除一个远程仓库$ git remote -v # 查看当前仓库对应的远程仓库地址 7、查看本地仓库的历史记录log：git log --author=你的用户名字 8、可以查看改动记录：git status 2、项目在本地，推送到远程12345678910cd &lt;项目的文件夹&gt; #【工作区：working dir】git init&lt;放项目文件等一系列操作&gt;git add . #【暂存区：stage 或 index】git commit -m "first commit" #【仓库区：HEAD】git remote add origin &lt;server&gt;git push -u origin master # 使用-u选项指定一个默认主机# 加了参数-u后，以后即可直接用git push代替git push origin mastergit push origin # 将当前分支推送到origin主机的对应分支 3、项目在远程，下载并推送123456789git clone &lt;server&gt; # 项目地址 https://github.com/xxxx.gitgit submodule update --init --recursive # 项目中带有submodulecd &lt;项目的文件夹&gt;# git pull origin master # 与远程同步，更新你的本地仓库至最新改动&lt;这里需要修改/添加文件，否则与原文件相比就没有变动&gt;git add .git commit -m "第一次提交"git push origin master# 然后如果需要账号密码的话就输入账号密码，这样就完成了一次提交 4、注意（本地和远程冲突）123456# 按照本文档新建的项目时，在码云平台仓库上已经存在 readme 文件，故在提交时可能会存在冲突，这时您需要选择的是保留线上的文件或者舍弃线上的文件。# 如果您舍弃线上的文件，则在推送时选择强制推送，强制推送需要执行下面的命令：git push origin master -f# 如果您选择保留线上的 readme 文件,则需要先执行：git pull origin master# 然后才可以推送 5、配置ssh key12345ssh-keygen -t rsa -C &apos;xxx@xxx.com&apos; # 然后一路回车(-C 参数是你的邮箱地址)打开文件 C:\Users\Administrator\.ssh\id_rsa.pub，复制内容打开 github --&gt; Settings --&gt; SSH and GPG keys --&gt; New SSH key把上一步中复制的内容粘贴到Key所对应的文本框，在Title对应的文本框中给这个sshkey设置一个名字，点击Add key按钮ssh -T git@github.com # 验证一下 二、分支操作相关操作1、创建分支：git branch feature_x 2、切换分支：git checkout feature_x 3、创建分支并切换过去：git checkout -b feature_x 4、删除分支：git branch -d feature_x 5、推送分支：git push origin feature_x 6、列出分支：git branch 7、重命名分支：git branch -m old_branch new_branch 三、标签1、添加标签：git tag -a &lt;tagname&gt; -m &lt;操作名&gt; 四、更新1、同步远程和本地合并：git pull == fetch merge 2、放弃本地，只要远程：git fetch origin 五、忽略 有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等。 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 .gitignore 文件123*.logtemp/vendor]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题对语义相似度计算-参赛总结]]></title>
    <url>%2F2018%2F08%2F10%2Fcompetition-summary%2F</url>
    <content type="text"><![CDATA[时间段：2018.06.10~2018.07.20 问题对语义相似度计算（从0到0.5+） 短短一个多月的时间，我学到了很多很多东西，从一个呆头小白初长成人。 首先，必须感谢我的导师能给我这个机会从头到尾完整地参加这次比赛，至始至终地为我们出谋划策，和我们探讨问题并答疑解惑，而且提供了各种宝贵的学习资料和服务器资源。 另外，也要特别感谢我的师兄一路无微不至的提点和帮助，和我一起找方法、看论文、搭模型、改代码，其实我们是从同一个起跑线开始的，到最后被师兄甩了好几条街 T_T。 虽然，比赛期间遇到了很多挫折，刚开始我们真的是一头雾水、无从下手，面对参加同样比赛的其他优秀选手（“老油条”）心里还是蛮慌的，好在勤能补拙，有团队配合，能够齐心协力、互相帮助，最终比赛的结果还算令人满意。 一、相关比赛123任务：语句匹配问题、语义等价判别、语义等价判定、等价；（语句的意图匹配）输入：一个语句对输出：一个数值（0-1之间），表明该语句对的相似程度 第三届魔镜杯大赛 问题相似度算法设计 2018 全国知识图谱与语义计算大会 任务三：微众银行智能客服问句匹配大赛 比赛平台：CCKS 2018 微众银行智能客服问句匹配大赛 ATEC蚂蚁开发者大赛 金融大脑-金融智能NLP服务 博客分享 … … 二、数据形式123456789101112131415161718魔镜杯：脱敏数据，所有原始文本信息都被编码成单字ID序列和词语ID序列。label,q1,q21,Q397345,Q5385940,Q193805,Q6992730,Q085471,Q676160... ...CCKS：中文的真实客服语料。用微信都6年，微信没有微粒贷功能 4。 号码来微粒贷 0微信消费算吗 还有多少钱没还 0交易密码忘记了找回密码绑定的手机卡也掉了 怎么最近安全老是要改密码呢好麻烦 0... ...蚂蚁：蚂蚁金服金融大脑的实际应用场景。1 怎么更改花呗手机号码 我的花呗是以前的手机号码，怎么更改成现在的支付宝的号码手机号 12 也开不了花呗，就这样了？完事了 真的嘛？就是花呗付款 03 花呗冻结以后还能开通吗 我的条件可以开通花呗借款吗 0... ... 三、解决方案（1）问题分析 预测问题对的相似程度，即判别问题对是属于类别1还是类别0，很明显这是一个NLP领域的分类问题，然而区别于传统的文本分类问题： 区别 传统文本分类 问题对相似度计算 输入 只有一个输入 有两个输入 句子长度 文本较长 句子长短不一、且较简短 特征 文本特征 语义特征 。。。 。。。 。。。 （2）数据分析 1、正负样本比例接近于 1：1； 2、相似的句子之间一般都会含有公共词/字符；也会出现包含很多公共词/字符，但句子主语不一样导致两个句子不相似的情况； 3、比赛的数据是没有经过预处理的（去停用词、繁体转简体、清洗）；另外数据中也存在很多脏数据（标注有误、错别字、漏字、简写），也很容易导致分词错误； 4、预训练的词向量数据（除非比赛方提供，否则还需要跟领域相关的语料来进行训练）； （3）分类模型其实我们之前是没有接触过这种类型的比赛的，也没有很多参赛的经验，而是刚刚从零学起，一步一步地摸索，沿着前人的脚步再延伸。 1、比赛方（魔镜杯）Demo：两个句子拼成一个文本，空格连接，以 tfidf 为特征，做逻辑回归；（研究官方Demo时发现代码里有bug：最后提交的是预测为0的概率，实际应该是1） 2、借鉴官方Demo，两个句子拼接，使用传统CNN做文本分类，准确率 80% 左右；经测试q1和q2两个句子分开单独处理后再合并做分类效果是明显好于q1和q2先合并再处理后做分类的； q1、q2 分开单独处理 共享卷积层 不共享卷积层 log_loss 0.258995 0.28949 3、微软发表的一篇论文[1]：DSSM模型（把条目映射成低维向量、计算查询和文档的cosine相似度，即一个查询语句对应多个文档，所以这个模型不太适用这个比赛） DSSM深度结构化语义模型原理 深度语义匹配模型-DSSM 及其变种 深度学习解决 NLP 问题：语义相似度计算 PaperWeekly 第37期 | 论文盘点：检索式问答系统的语义匹配模型（神经网络篇） 4、Quora Semantic Question Matching with Deep Learning 三个LSTM模型，可以作为以下介绍的模型的baseline，进本是基于LSTM和Attention展开。 5、The Stanford Natural Language Inference (SNLI) Corpus 一大堆模型及特征提取方法，很多都是用了模型融合。 6、MatchZoo 12个模型，可能这个工具包是针对QuoraQP数据已经调好了参数，在移植到我们这个比赛的时候效果不是很佳，但可以借鉴。 7、相关博客（句子对匹配方法） 使用深度双向LSTM模型构造社区问答系统 重现后，效果不是很好 深度学习笔记——基于双向RNN（LSTM、GRU）和Attention Model的句子对匹配方法 4个模型，其中 Soft Attention Model 实现后效果较好。 CNN在NLP领域的应用（2） 文本语义相似度计算 类似方法2 LSTM 句子相似度分析 LSTM 简化版 8、Siamese Network 孪生网络 Siamese network 孪生神经网络—一个简单神奇的结构 用于文本相似的Siamese Network Siamese Network理解（附代码） Siamese Network原理 9、ESIM （这个模型是所有模型里面实现后效果最好的，但也有改动，对于脱敏数据是不能实现TreeLSTM的） 源代码：ESIM_keras Kaggle Competition: Quora Question Pairs Problem a single model - ESIM 10、论文[2]里的4个模型：SSE、PWIM、DecAtt、ESIM 论文开源代码 11、论文[3]：BiMPM模型 github源码论文[4]：DR-BiLSTM模型 12、gensim 相似度查询 Gensim官方教程翻译（四）——相似度查询（Similarity Queries） gensim 相似度查询（Similarity Queries）(三) nltk-比较中文文档相似度-完整实例 nltk-比较中文文档相似度-完整实例 13、传统模型工具：xgboost(xgb)、lightgbm(lgb)、随机森林random forest(rf)、极端随机树 Extremely randomized trees(ET或Extra-Trees) 14、前10选手用到的模型 最终单模型的最好效果：log_loss = 0.205189 比赛期间，我实现或者在实现的基础上改进前前后后大概搭建了20多个模型，其实很多模型都还有很大的提升空间，局限于比赛的时间和自己的知识能力，而且在模型的细微之处、参数的初始化以及调参方面自己都没有什么经验，以致自己实现的模型的效果都没有师兄的好 (；へ：)。虽然我们没能进入拍拍贷“魔镜杯”比赛的决赛，但在导师的帮助和特殊关系下，我们也有幸了参加了 top10 选手精彩的决赛答辩(2018-7-24 09:00)，真的受益匪浅。 （4）模型调参 1、拍拍贷一同比赛的某位优秀选手（初赛第16名, 复赛第12名）分享的博客 智能客服问题相似度算法设计——第三届魔镜杯大赛第12名解决方案 队伍：moka_tree 团队 代码分享 2、其实，很多参数我自己设置的都是默认参数，具体没有做很多的微调： 123456789101112131415embedding_dim = 300 # 词向量的维度seq_length = 25 # 文本的最大长度filter_sizes = [3] # 卷积核尺寸列表num_classes = 2 # 类别数 is_pre_train = True # 是否为训练好的词向量is_trainable = True # 动态/静态词向量 num_filters = 300 # 卷积核数目rnn_num_layers = 2 # LSTM 隐藏层的个数attention_size = 300 # Attention 层的大小rnn_hidden_size = 300 # LSTM 隐藏层的大小dropout_keep_prob = 0.5 # dropout 保留比例learning_rate = 1e-3 # 学习率（设置自动衰减）batch_size = 128 # 每批训练的大小 3、参数初始化：跟上面博客里分享的一样，TensorFlow里面参数初始化不同，对结果的影响非常大，师兄推荐也是使用 Xavier 初始化；原本想用keras再实现一遍的，一方面不太熟悉，另一方面由于时间紧迫未能完成。 4、决赛答辩里，我们了解到很多选手并没有使用官方给定词级和字符级的词向量（不知道训练方法、参数、模型等），都自己训练了两种词向量（word2vec、glove）；另外也有用 w_vector * w_tfidf 作为 w 的词向量。 5、重点关注字向量：由于中文分词难度较大，特别是不同领域内的领域分词没有很好的解决方案（比赛数据为金融领域数据源），而且实验的效果也表明词级别是好于字级别的。 6、BatchNormalization + Spatial Dropout 1D （5）特征工程1、人工设计特征这部分是我们团队中来也公司的几个小伙伴做的， 他们参考并设计了很多有趣的特征。 统计特征：句长、公共词、fuzzywuzzy、stat_feature、cosine 欧式 明氏 切氏等距离、多项式 拉普拉斯 sigmod等核函数、重叠词、重叠字等特征； XGB_handcrafted_leaky 主题特征：powerful words、tfidf matrix、PCA、NMF、NLP feature； is_that_a_duplicate_quora_question 图特征 kaggle-quora-question-pairs 2、其他选手 计算QA pair的几种相似度：编辑距离、马氏距离、闵可夫斯基距离、WMD 使用 SVD、NMF对句中词向量降维 根据共现图，统计节点的degree，得到了两个比较强的特征：coo_q1_q2_degree_diff（问题1和问题2的degree的差异）、coo_max_degree（问题对最大的degree，进一步离散化做1-hot又得到3个特征） 问题对公共邻居的数量/比例 第一名：提取问题出入度、pagerank等特征；问题出现的次数以及频繁程度特征；将所有已知的问题构建同义问题集。问题集的构建不参与训练，只用于数据增强； 3、数据增强 第一名的方法 123456假设 Q1 在所有样本里出现2次，分别是1，Q1，Q21，Q3，Q1模型无法正确学习Q1与Q2/Q3的相同，而是会认为只要input里有Q1即为正样本。需要通过数据处理引导模型进行“比较”，而不是“拟合”。解决方案：通过构建一部分补充集（负例），对冲所有不平衡的问题。 4、后处理 传递关系 相似：（AB=1，AC=1）—&gt; BC=1 不相似：（AB=1，AC=0）—&gt; BC=0 第一名的方法：infer机制：除了判断test集的每个样本得分以外，还会通过已知同义问题集的其他样本比对进行加权；融合时轻微降低得分过高的模型权重，补偿正样本过多的影响；将已知确认的样本修正为0/1。 比别人差的一个重要原因：传递关系没有考虑到闭包！我们大概推了1253条，然而别人正例推了12568个样本，负例推了5129个样本。 ╥﹏╥ （6）模型融合 1、多模型的融合最常用的一个方法就是求平均，我使用这个方法后 logloss 有很大的提升（加权平均的几个结果都是线上提交后 logloss 在 0.205189~0.209739 之间）。 求平均的数量 2 4 7 8 9 线上提交 logloss 0.187845 0.185329 0.182613 0.179808 0.179063 2、同一个模型提升效果的常用方法就是多折交叉验证求平均，由于我们组内 GPU 服务器有限，这个就由模型效果比较好的师兄来完成了，而且提升也是非常明显的。 3、另外，也用了堆叠和混合（stacking与blending）。 每个模型 word level（官方词向量） 每个模型 word level（word2vec） 每个模型 word level（glove） 每个模型 char level（官方字向量） 每个模型 char level（word2vec） 每个模型 char level（glove） 4、kaggle比赛集成指南 5、模型微调（Finetune） 第一名的方法：gensim训练词向量；模型使用non_trainable词向量进行训练；将除了embedding的layer全部freeze，用低学习率finetune词向量层。 小 trick 贡献度 多模型的预测结果求平均 logloss 降低 2.6 个百分点 同一个模型10折交叉验证 logloss 降低 2 个 百分点 传递关系推导 logloss 降低 3.1 个千分点 四、比赛总结 1、比赛成绩（logloss / F1） 拍拍贷 初赛成绩（359只队伍） 复赛成绩（95只队伍） 我们 0.166100（第22名） 0.162495（第21名） moka_tree 0.163249（第16名） 0.151729（第12名） SKY 0.141329（第1名） 0.142658（第1名） CCKS 初赛成绩（138只队伍） 复赛成绩（50只队伍） 我们 0.85142（第24名） 0.84586（第4名） ThunderUp 0.86485（第1名） 0.85131（第1名） 2、经验体会 刚开始，我们都是尝试各种模型，不知道哪一个好，在这个上面花了不少时间，其实从平时就应该开始积累，关注最新研究、最新模型，多看一下论坛、kaggle、quora、github、和NLP相关的公众号等。 一定要从数据本身上做探索，研究各种特征，因为到比赛后期模型基本都相似了，很难再有更大的提升；从决赛答辩来看，前10的选手在数据特征上都下了非常大的功夫，比如图特征等。 一定要做交叉验证，求平均。比赛方提供的训练集如果只用了 0.9 的数据来训练模型，那么模型很大程度会丢失剩下的 0.1 的信息，如果做了交叉验证的话，就可以兼顾到所有训练集的特征信息。 从比赛角度讲，深度学习框架 keras 是好于 TensorFlow 的，因为 keras 一般在参数调试、参数初始化以及模型搭建上面都整合的非常好；从科研角度讲，Tensorflow 具有清晰的流程，可以帮助你更好的理解深度学习的完整过程。 到了比赛后期，多模型的融合一定会有帮助，因为这样可以结合不同的模型的优缺点；模型融合最简单的方法是就是求平均，再复杂点就是对不同的模型依据效果的好坏赋予不同的权重在加权求和。 之前一直很纳闷人工设计的传统特征是怎样可以和深度学习模型相结合的，通过这次比赛，我也学习到了很多传统的NLP模型（xgboost、lightgbm、随机森林、极端随机树等），设计的特征可以加入到最后一层MLP层进行训练。 一定要有团队配合，“三个臭皮匠，顶个诸葛亮”，“1+1&gt;2”，真的真的可以从别人身上学习到很多很多的东西。 一定要多看论文、多写代码，多请教师兄、导师，“纸上得来终觉浅，绝知此事要躬行。”，“冰冻三尺，非一日之寒。”，调参经验、模型的搭建很多都是来自平时的积累、练习。 作为一个小白，一定要比别人花更多的时间和努力，才能笨鸟先飞、勤能补拙。 再忙再累也要多运动、多锻炼，身体是革命的本钱，一定要爱惜身体，督促自己，实验室固然安逸，但整天坐着身体的机能肯定会下降，发际线正在颤抖。 “路漫漫其修远兮，我将上下而求索。” 五、参考文献 [1] Huang P S, He X, Gao J, et al. Learning deep structured semantic models for web search using clickthrough data[C]// ACM International Conference on Conference on Information &amp; Knowledge Management. ACM, 2013:2333-2338. [2] Lan W, Xu W. Neural Network Models for Paraphrase Identification, Semantic Textual Similarity, Natural Language Inference, and Question Answering[J]. 2018. [3] Wang Z, Hamza W, Florian R. Bilateral Multi-Perspective Matching for Natural Language Sentences[J]. 2017. [4] Ghaeini R, Hasan S A, Datla V, et al. DR-BiLSTM: Dependent Reading Bidirectional LSTM for Natural Language Inference[J]. 2018. 其他比赛选手总结 https://kexue.fm/archives/5743?from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>文本分类</tag>
        <tag>语义相似度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 一条命令12hexo clean &amp; hexo g &amp; hexo s # 默认端口号：4000hexo clean &amp; hexo g &amp; hexo server -p 5000 # 如果4000端口打不开，改用5000 简化命令123456789101112131415#（1）安装 NodeJS：https://nodejs.org/en/ ，安装好后打开 git bash node -v, npm -v # 测试#（2）安装 hexonpm install hexo-cli -g # hexo 全局安装# 若失败，配置国内镜像：https://www.jianshu.com/p/2afac1bc0af8hexo -v # 测试#（3）安装 hexok savenpm install hexo --save#（4）更新博客提交hexo c &amp; hexo g # 清理并生成hexo s -p 5000 # 本地服务hexo d # 推送 学习教程安装教程 Hexo 官方文档：https://hexo.io/zh-cn/docs/ Hexo 官方主题：https://hexo.io/themes/ Font Awesome Icons 图标：https://fontawesome.com/icons?from=io Google Fonts 字体：https://fonts.google.com/ Hexo Next 官方文档：http://theme-next.iissnan.com/getting-started.html hexo从零开始到搭建完整 如何把自己写的网页挂在Github上面（完整教程） 手把手教你 hexo + github搭建自己的博客以及个人主页 Hexo博客 新手安装及使用教程 优化教程 Hexo的Next主题详细配置 Hexo+Next个人博客主题优化 Hexo | （二）Next主题个性化设置 hexo的next主题个性化教程:打造炫酷网站 如何在markdown中插入数学公式：链接1 链接2 More info: Deployment]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
